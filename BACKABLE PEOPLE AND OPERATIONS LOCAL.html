<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>People & Operations - The Foundation Engine</title>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 3em;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header .subtitle {
            color: #764ba2;
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .intro-text {
            font-size: 1.2em;
            color: #666;
            max-width: 700px;
            margin: 0 auto 30px;
        }

        .progress-container {
            background: rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255,255,255,0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            border-radius: 6px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            color: #667eea;
            font-weight: 700;
            font-size: 1.1em;
        }

        .expansion-indicator {
            text-align: center;
            color: #764ba2;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .connection-status.connected {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }

        .connection-status.disconnected {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }

        .connection-status.checking {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
        }

        /* User Input Section */
        .user-input-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .user-input-section.hidden {
            display: none;
        }

        .user-input-section h2 {
            color: #667eea;
            margin-bottom: 25px;
            text-align: center;
            font-size: 2em;
        }

        .user-input-field {
            margin-bottom: 25px;
        }

        .user-input-field label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2d3748;
            font-size: 1.1em;
        }

        .user-input-field input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .user-input-field input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .start-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        /* Mind Expansion Sections */
        .mind-expansion {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            display: none;
        }

        .mind-expansion.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .expansion-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .expansion-title {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: 800;
        }

        .expansion-subtitle {
            font-size: 1.4em;
            color: #764ba2;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .expansion-description {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 30px;
        }

        /* Question Styles */
        .question {
            margin-bottom: 50px;
            padding: 30px;
            background: linear-gradient(135deg, #f8f9ff 0%, #fff 100%);
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            position: relative;
            overflow: hidden;
        }

        .question::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
        }

        .question-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
        }

        .question-subtext {
            font-size: 1em;
            color: #666;
            margin-bottom: 25px;
            font-style: italic;
        }

        /* Auto-Save Indicator */
        .auto-save-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 0.8em;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: 600;
        }

        .auto-save-indicator.saving {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }

        .auto-save-indicator.saved {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }

        .auto-save-indicator.error {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }

        /* Battle Card Options */
        .card-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .card-option {
            padding: 25px;
            background: white;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .card-option:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.15);
        }

        .card-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.25);
        }

        .card-option-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .card-option-subtitle {
            font-size: 0.95em;
            color: #666;
            line-height: 1.5;
        }

        /* Multiple Choice */
        .checkbox-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .checkbox-option {
            padding: 20px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .checkbox-option:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .checkbox-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.05));
            transform: translateY(-3px);
        }

        .checkbox-option input[type="checkbox"] {
            position: absolute;
            opacity: 0;
        }

        .checkbox-option-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 1em;
        }

        /* Select Options */
        .select-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .select-option {
            padding: 20px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .select-option:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .select-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.05));
            transform: translateY(-3px);
        }

        .select-option input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .select-option-label {
            font-weight: 600;
            color: #2d3748;
            font-size: 1em;
        }

        /* Single Slider */
        .slider-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid #e2e8f0;
        }

        .slider-value {
            text-align: center;
            font-weight: 700;
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .slider-input {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e2e8f0;
            outline: none;
            margin: 15px 0;
            -webkit-appearance: none;
        }

        .slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #666;
            font-weight: 600;
        }

        /* Matrix Sliders */
        .matrix-slider-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid #e2e8f0;
        }

        .matrix-slider-item {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 12px;
        }

        .matrix-slider-label {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1em;
        }

        .matrix-slider-value {
            text-align: center;
            font-weight: 700;
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .matrix-slider-input {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e2e8f0;
            outline: none;
            margin: 15px 0;
            -webkit-appearance: none;
        }

        .matrix-slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .matrix-slider-scale {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
            font-weight: 500;
        }

        /* Tournament Battle */
        .tournament-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 1px solid #e2e8f0;
        }

        .battle-round-indicator {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 15px;
        }

        .battle-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .battle-option {
            padding: 30px 20px;
            background: #f8f9ff;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .battle-option:hover {
            border-color: #667eea;
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .battle-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.05));
            transform: scale(1.02);
        }

        /* Text Input */
        .text-input {
            width: 100%;
            padding: 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 1em;
            transition: all 0.3s ease;
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .text-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .char-counter {
            text-align: right;
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
            font-weight: 500;
        }

        /* Navigation */
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 40px;
            padding: 25px;
            background: rgba(255,255,255,0.9);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .nav-button {
            padding: 15px 30px;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .nav-button.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .nav-button.primary:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .nav-button.secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .nav-button.secondary:hover:not(:disabled) {
            background: #cbd5e0;
            transform: translateY(-2px);
        }

        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Final Section */
        .final-section {
            text-align: center;
            padding: 60px 40px;
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            border-radius: 20px;
            color: white;
            display: none;
        }

        .final-section.active {
            display: block;
        }

        .final-title {
            font-size: 3em;
            font-weight: 800;
            margin-bottom: 25px;
        }

        .final-subtitle {
            font-size: 1.5em;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .submit-button {
            padding: 20px 50px;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 30px;
        }

        .submit-button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(245, 87, 108, 0.4);
        }

        .submit-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Status Messages */
        .status-message {
            text-align: center;
            padding: 20px;
            margin: 25px 0;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1.1em;
        }

        .status-success {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }

        .status-error {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }

        .status-info {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .expansion-title {
                font-size: 1.8em;
            }
            
            .card-options {
                grid-template-columns: 1fr;
            }
            
            .checkbox-options {
                grid-template-columns: 1fr;
            }

            .navigation {
                flex-direction: column;
                gap: 15px;
            }

            .nav-button {
                width: 100%;
            }

            .battle-options {
                grid-template-columns: 1fr;
            }

            .connection-status {
                top: 10px;
                right: 10px;
                font-size: 0.8em;
                padding: 8px 12px;
            }
        }
    </style>
    </head>
    <body>
        <!-- Connection Status Indicator -->
        <div class="connection-status checking" id="connectionStatus">üîÑ Checking Connection...</div>

        <div class="container">
            <!-- User Input Section -->
            <div class="user-input-section" id="userInputSection">
                <h2>üë• People & Operations Foundation Profile</h2>
                <p style="text-align: center; font-size: 1.1em; color: #666; margin-bottom: 30px;">
                    Never Alone, Always Ahead - The Foundation Engine Assessment with Auto-Save
                </p>
                <div class="user-input-field">
                    <label for="userIdInput">Enter Your User ID:</label>
                    <input type="text" id="userIdInput" placeholder="e.g., 330 or your email" required>
                </div>
                <div class="user-input-field">
                    <label for="businessNameInput">Business Name:</label>
                    <input type="text" id="businessNameInput" placeholder="e.g., Your Company Name" required>
                </div>
                <button class="start-button" id="startButton">Begin Foundation Assessment</button>
            </div>

            <!-- Main Header (shown after start) -->
            <div class="header" id="assessmentHeader" style="display: none;">
                <h1>üë• People & Operations</h1>
                <div class="subtitle">The Foundation Engine with Auto-Save</div>
                <p class="intro-text">
                    Never Alone, Always Ahead - Understanding your human architecture and operational foundations
                </p>
                <div class="progress-container">
                    <div class="expansion-indicator" id="expansionIndicator">Question 1 of 16</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">0% Complete</div>
                </div>
            </div>

            <!-- Questions Container -->
            <div id="questionsContainer"></div>

            <!-- Final Section -->
            <div class="final-section" id="finalSection">
                <div class="final-title">üèÜ Foundation Assessment Complete</div>
                <div class="final-subtitle">Your People & Operations Intelligence Profile is Ready!</div>

                <p style="font-size: 1.2em; line-height: 1.7; margin: 30px 0;">
                    You've completed the comprehensive People & Operations Foundation Engine assessment.
                    Your personalized foundation analysis is being generated to reveal your human architecture strengths and opportunities.
                </p>

                <button class="submit-button" id="submitButton">
                    Generate My Foundation Intelligence Report
                </button>

                <div id="submission-status" class="status-message" style="display: none;"></div>
            </div>

            <!-- Navigation -->
            <div class="navigation" id="navigationSection" style="display: none;">
                <button class="nav-button secondary" id="prevBtn" disabled>‚Üê Previous</button>
                <div id="questionStatus" style="font-weight: 600; color: #667eea;">Question 1 of 16</div>
                <button class="nav-button primary" id="nextBtn">Next Question ‚Üí</button>
            </div>
        </div>

        <script>
        // Configuration - Updated to match your backend
        const API_BASE_URL = 'http://127.0.0.1:8001'; // Your FastAPI backend port
        
        // Global variables
        let currentUserId = null;
        let currentBusinessName = null;
        let assessmentStarted = false;
        let currentQuestionIndex = 0;
        let responses = {};
        let questionStates = {};
        let startTime = new Date();
        let questionStartTimes = {};
        let backendConnected = false;
        
        // Auto-save variables
        let autoSaveIndicator = null;
        let saveQueue = [];
        let isSaving = false;
        
        // Tournament battle state
        let tournamentState = {};
        
        // Chapter timing tracking
        let chapterTimings = {};
        let currentChapterStartTime = null;
        let currentChapter = null;
        
        // Behavioral analytics tracking
        let behaviorTracker = {
            mouseMovements: [],
            clickPatterns: [],
            keystrokeTimings: [],
            totalKeystrokes: 0,
            scrollBehavior: [],
            engagementData: {
                totalDistance: 0,
                totalMovements: 0,
                startTime: new Date(),
                interactions: 0
            }
        };
        
        // Session metadata
        let sessionMetadata = {
            sessionId: '',
            startTime: null,
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            screenResolution: `${screen.width}x${screen.height}`,
            viewportSize: { width: window.innerWidth, height: window.innerHeight },
            devicePixelRatio: window.devicePixelRatio,
            colorDepth: screen.colorDepth,
            touchSupport: 'ontouchstart' in window,
            cookiesEnabled: navigator.cookieEnabled,
            onlineStatus: navigator.onLine,
            referrer: 'direct',
            entryUrl: window.location.href
        };

        // Mouse tracking
        let lastMousePosition = { x: 0, y: 0, timestamp: Date.now() };

        // API Functions - Updated to match your backend endpoints
        async function makeAPICall(endpoint, method = 'GET', data = null) {
            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                };
                
                if (data) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error(`API call failed: ${method} ${endpoint}`, error);
                throw error;
            }
        }

        async function checkBackendConnection() {
            console.log('üîÑ Checking backend connection...');
            updateConnectionStatus('checking');
            
            try {
                const response = await makeAPICall('/health');
                backendConnected = response.status === 'healthy';
                console.log('‚úÖ Backend connected:', backendConnected);
                updateConnectionStatus('connected');
                return backendConnected;
            } catch (error) {
                console.log('‚ùå Backend connection failed:', error.message);
                backendConnected = false;
                updateConnectionStatus('disconnected');
                return false;
            }
        }

        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            
            statusElement.className = `connection-status ${status}`;
            
            switch (status) {
                case 'connected':
                    statusElement.textContent = '‚úÖ Connected';
                    break;
                case 'disconnected':
                    statusElement.textContent = '‚ùå Offline Mode';
                    break;
                case 'checking':
                    statusElement.textContent = 'üîÑ Checking...';
                    break;
            }
        }

        // Save progress using your backend endpoint
        async function saveProgressToBackend(currentChapterNum) {
            if (!backendConnected || !currentUserId) {
                console.log('‚è≠Ô∏è Skipping progress save - offline mode or no user ID');
                return false;
            }

            try {
                console.log(`üíæ Saving progress to backend: chapter ${currentChapterNum}`);
                
                const assessmentData = buildPeopleAssessmentData();
                
                const response = await makeAPICall('/people_ops_assessment_progress', 'POST', {
                    user_id: currentUserId,
                    business_name: currentBusinessName || 'Unknown Business',
                    assessment_data: assessmentData,
                    current_chapter: currentChapterNum,
                    auto_save: true
                });
                
                console.log('‚úÖ Progress saved to backend:', response);
                return true;
                
            } catch (error) {
                console.error('‚ùå Progress save failed:', error);
                return false;
            }
        }

        // Load previous progress using your backend endpoint
        async function loadPreviousProgress(userId) {
            if (!backendConnected || !userId) {
                console.log('‚è≠Ô∏è Skipping progress load - offline mode or no user ID');
                return null;
            }

            try {
                console.log(`üì• Loading previous progress for user ${userId}`);
                
                const response = await makeAPICall(`/people_ops_assessment_progress/${userId}`);
                
                if (response.status === 'found' && response.assessment_data) {
                    console.log('‚úÖ Previous progress loaded:', response);
                    return response;
                }
                
                console.log('‚ÑπÔ∏è No previous progress found');
                return null;
                
            } catch (error) {
                console.error('‚ùå Progress load failed:', error);
                return null;
            }
        }

        // Initialize behavioral tracking
        function initializeBehavioralTracking() {
            // Mouse movement tracking
            document.addEventListener('mousemove', function(e) {
                const now = Date.now();
                const currentPos = { x: e.clientX, y: e.clientY, timestamp: now };
                
                // Calculate distance from last position
                const distance = Math.sqrt(
                    Math.pow(currentPos.x - lastMousePosition.x, 2) + 
                    Math.pow(currentPos.y - lastMousePosition.y, 2)
                );
                
                behaviorTracker.engagementData.totalDistance += distance;
                behaviorTracker.engagementData.totalMovements++;
                
                // Store mouse movements (sample every 100ms to prevent too much data)
                if (now - lastMousePosition.timestamp > 100) {
                    behaviorTracker.mouseMovements.push({
                        x: currentPos.x,
                        y: currentPos.y,
                        timestamp: new Date(now).toISOString(),
                        distance: distance
                    });
                    lastMousePosition = currentPos;
                }
            });
            
            // Click tracking
            document.addEventListener('click', function(e) {
                behaviorTracker.clickPatterns.push({
                    x: e.clientX,
                    y: e.clientY,
                    timestamp: new Date().toISOString(),
                    target: e.target.tagName
                });
                behaviorTracker.engagementData.interactions++;
            });
            
            // Keyboard tracking
            document.addEventListener('keydown', function(e) {
                behaviorTracker.keystrokeTimings.push({
                    key: e.key,
                    timestamp: new Date().toISOString()
                });
                behaviorTracker.totalKeystrokes++;
            });
            
            // Scroll tracking
            document.addEventListener('scroll', function(e) {
                behaviorTracker.scrollBehavior.push({
                    scrollY: window.scrollY,
                    timestamp: new Date().toISOString()
                });
            });
        }

        // All questions from the People & Operations assessment
        const allQuestions = [
            {
                id: "1.1",
                type: "card",
                section: "The People Architecture",
                subSection: "Roles and Accountability",
                number: "1.1",
                question: "What's the reality of roles and accountability in your business?",
                subText: "The right structure depends on your size - what works for a 3-person startup would cripple a 30-person business.",
                options: [
                    {
                        title: "Crystal Clear",
                        subtitle: ["Defined roles, specific accountabilities, everyone knows their lane"]
                    },
                    {
                        title: "Mostly Defined",
                        subtitle: ["Clear on the big stuff, some flexibility on the details"]
                    },
                    {
                        title: "Fluid & Functional",
                        subtitle: ["We adapt roles as needed, everyone pitches in where required"]
                    },
                    {
                        title: "All Hands, All Tasks",
                        subtitle: ["Small team, we all do everything together"]
                    }
                ]
            },
            {
                id: "1.2",
                type: "multi-slider",
                section: "The People Architecture",
                subSection: "Key-Person Risk Assessment",
                number: "1.2",
                question: "How vulnerable is your business to key-person risk?",
                subText: "If these critical people were unavailable tomorrow, how vulnerable would your business be? Your biggest risks hide in your greatest dependencies.",
                options: [
                    "Strategic Planning - Vision, direction, big decisions",
                    "Sales & Client Relations - Revenue generation and client relationships",
                    "Operations - Day-to-day business delivery",
                    "Finance & Administration - Money management and business admin",
                    "Technical Expertise - Core skills that deliver your service/product",
                    "Product Development - Innovation and new offerings"
                ],
                min: 0,
                max: 5,
                step: 1,
                minLabel: "Low Risk",
                maxLabel: "High Risk"
            },
            {
                id: "1.3",
                type: "checkbox",
                section: "The People Architecture",
                subSection: "Business Independence",
                number: "1.3",
                question: "What does going on holiday actually look like for you?",
                subText: "Picture this: you've just landed in your dream destination for a 2-week family holiday. Based on how your business currently operates, what's your reality? How you holiday reveals how well your business runs without you.",
                options: [
                    "Command Centre Mode - Laptop packed, phone always on, managing everything remotely",
                    "Scheduled Check-ins - Set times to call in, handle urgent issues, then back to holiday",
                    "Emergency Only - Phone's on for real emergencies, but mostly trying to switch off",
                    "Daily Pulse Check - Quick morning calls to stay in the loop, then holiday mode",
                    "Airplane Mode - Phone off, team knows not to contact unless the building's on fire",
                    "What Business? - Complete digital detox, team handles everything, I'm genuinely off"
                ]
            },
            {
                id: "2.1",
                type: "slider",
                section: "The Leadership Reality",
                subSection: "Leadership Self-Assessment",
                number: "2.1",
                question: "How would you rate your own people leadership skills?",
                subText: "Honest self-assessment: where do you see your leadership capabilities right now?",
                min: 0,
                max: 5,
                step: 0.1,
                minLabel: "Still developing",
                maxLabel: "Confident and effective"
            },
            {
                id: "2.2",
                type: "slider",
                section: "The Leadership Reality",
                subSection: "Leadership Perception",
                number: "2.2",
                question: "If your team filled out an anonymous survey about your leadership, what would they say?",
                subText: "Sometimes the most revealing perspective is seeing ourselves through others' eyes.",
                min: 0,
                max: 5,
                step: 0.1,
                minLabel: "They'd say I need significant development",
                maxLabel: "They'd say I'm an exceptional people leader"
            },
            {
                id: "2.3",
                type: "battle",
                section: "The Leadership Reality",
                subSection: "Leadership Development Priority",
                number: "2.3",
                question: "Which leadership challenge is your biggest growth barrier right now?",
                subText: "We'll run these through battle rounds to identify your top leadership challenge. Your biggest barriers reveal your next breakthrough opportunities.",
                includes: "ranking",
                options: [
                    "Holding On",
                    "Letting Go", 
                    "Pushing",
                    "Pulling",
                    "Present",
                    "Future",
                    "Individual",
                    "Team"
                ]
            },
            {
                id: "2.4",
                type: "slider",
                section: "The Leadership Reality",
                subSection: "Organizational Leadership Depth",
                number: "2.4",
                question: "What's the leadership depth in your organisation?",
                subText: "With your current team size, this question becomes particularly relevant to achieving your #growth_goals. Different business stages need different leadership depth and development approaches. You can't scale what you can't delegate. You can't delegate without leaders.",
                min: 0,
                max: 5,
                step: 0.1,
                minLabel: "No leadership depth",
                maxLabel: "Strong leadership at multiple levels"
            },
            {
                id: "3.1",
                type: "checkbox",
                section: "The Revenue Engine",
                subSection: "Revenue Responsibility",
                number: "3.1",
                question: "Who's really driving revenue in your business?",
                subText: "If everyone owns revenue, no one owns revenue.",
                options: [
                    "Clear Revenue Champions - Dedicated roles with defined KPIs and support",
                    "Shared Revenue Responsibility - Multiple people contributing to revenue generation",
                    "Owner-Dependent Revenue - I'm still the primary revenue generator",
                    "Revenue Responsibility Confusion - It's unclear who owns revenue outcomes"
                ]
            },
            {
                id: "3.2",
                type: "multi-slider",
                section: "The Revenue Engine",
                subSection: "Team Accountability",
                number: "3.2",
                question: "Rate your team's clarity on reporting and accountability:",
                subText: "Confusion is the enemy of execution.",
                options: [
                    "Reporting Structure - Who reports to whom",
                    "Individual Accountability - What each person owns",
                    "Performance Expectations - Regular feedback and reviews",
                    "Decision Authority - Who can decide what"
                ],
                min: 0,
                max: 5,
                step: 1,
                minLabel: "Unclear",
                maxLabel: "Crystal Clear"
            },
            {
                id: "4.1",
                type: "multi-slider",
                section: "The People Systems Reality",
                subSection: "People Process Assessment",
                number: "4.1",
                question: "How systematic are your people processes?",
                subText: "Rate the level of structure in your people management. The sophistication of your people systems determines how smoothly you can scale.",
                options: [
                    "Hiring Process - From job posting to final decision",
                    "Onboarding System - Getting new people productive quickly",
                    "Performance Management - Regular reviews, feedback, and development",
                    "OH&S Procedures - Workplace health and safety protocols",
                    "Exit Process - How departures are handled (voluntary and involuntary)"
                ],
                min: 0,
                max: 5,
                step: 1,
                minLabel: "Ad hoc/None",
                maxLabel: "Highly Systematic"
            },
            {
                id: "5.1",
                type: "slider",
                section: "The Culture Engine",
                subSection: "Team Engagement",
                number: "5.1",
                question: "Rate your team's engagement level:",
                subText: "Engagement is the multiplier that turns effort into results.",
                min: 0,
                max: 5,
                step: 0.1,
                minLabel: "Disengaged",
                maxLabel: "Highly engaged"
            },
            {
                id: "5.2",
                type: "card",
                section: "The Culture Engine",
                subSection: "Decision Making Effectiveness",
                number: "5.2",
                question: "How effective is decision-making in your business?",
                subText: "The speed of your decisions determines the speed of your progress.",
                options: [
                    {
                        title: "Efficient Decisions",
                        subtitle: ["Made quickly at the right level"]
                    },
                    {
                        title: "Occasional Delays",
                        subtitle: ["Sometimes unclear authority slows things"]
                    },
                    {
                        title: "Frequent Bottlenecks",
                        subtitle: ["Decision-making gets stuck regularly"]
                    },
                    {
                        title: "Decision Struggles",
                        subtitle: ["We're not good at making decisions"]
                    }
                ]
            },
            {
                id: "5.3",
                type: "checkbox",
                section: "The Culture Engine",
                subSection: "Knowledge Management",
                number: "5.3",
                question: "How does knowledge flow in your organisation?",
                subText: "Choose all that apply. Information that isn't shared is opportunity that isn't captured.",
                options: [
                    "Documented Systems - Critical information is captured and shared",
                    "Cross-Training Culture - People learn each other's functions",
                    "Information Silos - Knowledge stays within departments",
                    "Individual Knowledge - Information lives in people's heads",
                    "Collaboration Tools - We have effective systems for working together"
                ]
            },
            {
                id: "6.1",
                type: "checkbox",
                section: "The Warning Signs",
                subSection: "People-Related Incidents",
                number: "6.1",
                question: "Have any of these people-related incidents occurred in the past 12 months?",
                subText: "Choose all that apply. Past incidents are future insights if you're willing to learn from them.",
                options: [
                    "Sudden Departure - Key employee left with little notice",
                    "Workplace Conflict - Significant conflict requiring intervention",
                    "Compliance Issues - HR policy violation or compliance problem",
                    "Performance Impact - Staff issues affected client satisfaction",
                    "Client Relationship Loss - Lost clients due to staff problems",
                    "Delivery Failures - Couldn't deliver because of people constraints"
                ]
            },
            {
                id: "7.1",
                type: "checkbox",
                section: "The Operational Foundations",
                subSection: "Performance Limiting Challenges",
                number: "7.1",
                question: "What people challenges are secretly limiting your performance?",
                subText: "Choose all that apply. Your biggest opportunities often hide behind your biggest frustrations.",
                options: [
                    "Recruitment Struggles - Finding the right people",
                    "Skills Gaps - Missing capabilities we need",
                    "Leadership Capacity - Not enough management bandwidth",
                    "Retention Issues - Keeping good people",
                    "Culture Challenges - Team dynamics and engagement",
                    "System Failures - Inadequate processes and tools"
                ]
            },
            {
                id: "7.2",
                type: "select",
                section: "The Operational Foundations",
                subSection: "Talent Development Approach",
                number: "7.2",
                question: "How do you approach talent development?",
                subText: "The businesses that grow are the ones that grow people.",
                options: [
                    "Systematic Development - Formal plans and clear succession paths",
                    "Informal Opportunities - We provide development when we can",
                    "Reactive Approach - Address development when problems arise",
                    "No Structured Approach - People development isn't systematic"
                ]
            },
            {
                id: "8.1",
                type: "multi-slider",
                section: "The Operational Systems Reality",
                subSection: "Systems Assessment",
                number: "8.1",
                question: "How systematic are your business operations?",
                subText: "Rate the level of structure in your core business processes. The sophistication of your systems determines your capacity to scale.",
                options: [
                    "Standard Operating Procedures (SOPs) - Documented step-by-step processes",
                    "Quality Control Systems - Consistent delivery and error prevention",
                    "Workflow Management - How work moves through your business",
                    "Data Management - How information is captured, stored, and used",
                    "Technology Integration - How well your tools work together"
                ],
                min: 0,
                max: 5,
                step: 1,
                minLabel: "Ad hoc/None",
                maxLabel: "Highly Systematic"
            },
            {
                id: "8.2",
                type: "checkbox",
                section: "The Operational Systems Reality",
                subSection: "Current Tools and Systems",
                number: "8.2",
                question: "What business management tools and systems do you currently use?",
                subText: "Choose all that apply. The right tools amplify your team's effectiveness.",
                options: [
                    "Project Management - Tools for tracking tasks and deadlines",
                    "CRM Systems - Customer relationship management",
                    "Financial Software - Accounting, invoicing, expense tracking",
                    "Communication Platforms - Team messaging, video calls, collaboration",
                    "Document Management - File storage, version control, sharing",
                    "Analytics & Reporting - Business intelligence and performance tracking"
                ]
            },
            {
                id: "8.3",
                type: "text",
                section: "The Operational Systems Reality",
                subSection: "Tech Stack Details",
                number: "8.3",
                question: "What are your most critical business tools?",
                subText: "Based on your business type and industry, we're curious about your current tech stack. Your tech stack reveals your operational maturity and integration opportunities.",
                placeholder: "Examples: Google Workspace, HubSpot, Xero, Slack, Zoom...",
                required: false,
                maxLength: 500
            },
            {
                id: "8.4",
                type: "slider",
                section: "The Operational Systems Reality",
                subSection: "Systems Alignment",
                number: "8.4",
                question: "How aligned are your current systems with your business goals?",
                subText: "Given your growth ambitions, this alignment becomes critical to your success. The gap between where you're going and how you're organised is where growth gets stuck.",
                min: 0,
                max: 5,
                step: 0.1,
                minLabel: "Completely misaligned",
                maxLabel: "Perfectly aligned"
            },
            {
                id: "9.1",
                type: "text",
                section: "Deep Reflection",
                subSection: "Leadership Challenges",
                number: "9.1",
                question: "What's your biggest people or leadership challenge right now?",
                subText: "The challenge you name is the one we can help you solve.",
                placeholder: "Managing rapid growth with limited leadership depth...",
                required: false,
                maxLength: 500
            },
            {
                id: "9.2",
                type: "text",
                section: "Deep Reflection",
                subSection: "Transformational Opportunities",
                number: "9.2",
                question: "What organisational improvement would transform your business?",
                subText: "The transformation you can imagine is the one you can create.",
                placeholder: "Building a management layer that can operate independently...",
                required: false,
                maxLength: 500
            }
        ];

        // Global functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createSafeId(questionId) {
            return questionId.replace(/\./g, '_');
        }

        function initializeQuestionState(questionId) {
            if (!questionStates[questionId]) {
                console.log(`üÜï Initializing question state for ${questionId}`);
                questionStates[questionId] = {
                    status: "in_progress",
                    first_answered_at: null,
                    last_modified_at: null,
                    modification_count: 0
                };
            }
            if (!questionStartTimes[questionId]) {
                questionStartTimes[questionId] = new Date();
            }
        }

        // Auto-save individual response to backend using your endpoint
        async function autoSaveResponse(questionId, responseData) {
            console.log(`üíæ Auto-saving response for question ${questionId}`);
            
            if (!backendConnected || !currentUserId) {
                console.log(`‚è≠Ô∏è Skipping auto-save for ${questionId} - offline mode`);
                showAutoSaveIndicator('saved');
                return true;
            }
            
            showAutoSaveIndicator('saving');
            
            try {
                // Calculate current chapter for progress tracking
                const question = allQuestions.find(q => q.id === questionId);
                const currentChapterNum = getCurrentChapterNumber(question?.section);
                
                // Save progress using your backend endpoint
                await saveProgressToBackend(currentChapterNum);
                
                console.log(`‚úÖ Response auto-saved for ${questionId}`);
                showAutoSaveIndicator('saved');
                
                return true;
            } catch (error) {
                console.error(`‚ùå Auto-save failed for ${questionId}:`, error);
                showAutoSaveIndicator('error');
                return false;
            }
        }

        function getCurrentChapterNumber(sectionName) {
            const sectionToChapter = {
                "The People Architecture": 1,
                "The Leadership Reality": 2,
                "The Revenue Engine": 3,
                "The People Systems Reality": 4,
                "The Culture Engine": 5,
                "The Warning Signs": 6,
                "The Operational Foundations": 7,
                "The Operational Systems Reality": 8,
                "Deep Reflection": 9
            };
            
            return sectionToChapter[sectionName] || 1;
        }

        // Show auto-save indicator
        function showAutoSaveIndicator(status) {
            if (!autoSaveIndicator) {
                autoSaveIndicator = document.createElement('div');
                autoSaveIndicator.className = 'auto-save-indicator';
                
                const questionContainer = document.querySelector('.question');
                if (questionContainer) {
                    questionContainer.appendChild(autoSaveIndicator);
                }
            }
            
            autoSaveIndicator.className = `auto-save-indicator ${status}`;
            
            switch (status) {
                case 'saving':
                    autoSaveIndicator.textContent = 'üíæ Saving...';
                    break;
                case 'saved':
                    autoSaveIndicator.textContent = '‚úÖ Saved';
                    setTimeout(() => {
                        if (autoSaveIndicator) autoSaveIndicator.style.display = 'none';
                    }, 2000);
                    break;
                case 'error':
                    autoSaveIndicator.textContent = '‚ùå Save Error';
                    break;
            }
            
            autoSaveIndicator.style.display = 'block';
        }

        async function startAssessment() {
    console.log('üöÄ Starting People & Operations Assessment');
    
    const userIdInput = document.getElementById('userIdInput');
    const businessNameInput = document.getElementById('businessNameInput');
    const userId = userIdInput.value.trim();
    const businessName = businessNameInput.value.trim();
    
    if (!userId || !businessName) {
        console.error('‚ùå Missing required fields');
        alert('Please enter both your User ID and Business Name to continue.');
        return;
    }
    
    currentUserId = userId;
    currentBusinessName = businessName;
    console.log('‚úÖ User details set:', { userId: currentUserId, businessName: currentBusinessName });
    
    // Show loading state
    const startButton = document.getElementById('startButton');
    const originalText = startButton.innerHTML;
    startButton.innerHTML = 'Loading Assessment... <div class="loading-spinner"></div>';
    startButton.disabled = true;
    
    try {
        // Check backend connection
        await checkBackendConnection();
        
        let assessmentLoaded = false;
        
        if (backendConnected) {
            // Try to load existing progress using your backend endpoint
            const existingProgress = await loadPreviousProgress(currentUserId);
            
            if (existingProgress && existingProgress.assessment_data) {
                console.log('üìä Found existing progress:', existingProgress);
                
                // Check if assessment is mostly complete
                const progressData = existingProgress.assessment_data;
                const responseCount = progressData.responses ? progressData.responses.length : 0;
                const isNearComplete = responseCount >= allQuestions.length * 0.8;
                const isFullyComplete = responseCount >= allQuestions.length;
                
                console.log(`üìà Progress analysis: ${responseCount}/${allQuestions.length} responses`);
                console.log(`üìà Near complete: ${isNearComplete}, Fully complete: ${isFullyComplete}`);
                
                if (isFullyComplete) {
                    console.log('üéØ Assessment is FULLY complete - providing edit access');
                    
                    // Set up UI with FULL navigation access
                    document.getElementById('userInputSection').classList.add('hidden');
                    document.getElementById('assessmentHeader').style.display = 'block';
                    document.getElementById('navigationSection').style.display = 'flex'; // ‚Üê CRITICAL: Always show navigation
                    
                    // Restore state
                    restoreAssessmentState(progressData);
                    
                    // Show LAST question instead of final section to allow navigation
                    showQuestion(allQuestions.length - 1);
                    
                    // Show helpful message about editing capabilities
                    showStatusMessage(`‚úÖ Assessment complete! Navigate through questions to review/edit responses. Click "Complete Assessment" when ready to submit.`, 'success');
                    
                    assessmentLoaded = true;
                    
                } else if (isNearComplete) {
                    console.log('üèÅ Assessment is near completion but not fully complete');
                    
                    // Set up UI
                    document.getElementById('userInputSection').classList.add('hidden');
                    document.getElementById('assessmentHeader').style.display = 'block';
                    document.getElementById('navigationSection').style.display = 'flex'; // ‚Üê Always show navigation
                    
                    // Restore state and continue
                    restoreAssessmentState(progressData);
                    
                    // Find where to continue
                    const nextQuestionIndex = findNextQuestionIndex();
                    if (nextQuestionIndex < allQuestions.length) {
                        showQuestion(nextQuestionIndex);
                        showStatusMessage(`üì• Restored ${responseCount} previous responses. Continuing from where you left off.`, 'success');
                    } else {
                        // This should rarely happen now, but handle gracefully
                        showQuestion(allQuestions.length - 1);
                        showStatusMessage(`‚úÖ Assessment ready for review. Navigate through questions to edit responses.`, 'success');
                    }
                    
                    assessmentLoaded = true;
                    
                } else if (responseCount > 0) {
                    console.log('‚ñ∂Ô∏è Continuing existing assessment with partial progress');
                    
                    // Set up UI
                    document.getElementById('userInputSection').classList.add('hidden');
                    document.getElementById('assessmentHeader').style.display = 'block';
                    document.getElementById('navigationSection').style.display = 'flex';
                    
                    // Restore state
                    restoreAssessmentState(progressData);
                    
                    // Continue from next unanswered question
                    const nextQuestionIndex = findNextQuestionIndex();
                    showQuestion(nextQuestionIndex);
                    showStatusMessage(`üì• Restored ${responseCount} previous responses. Continuing assessment.`, 'success');
                    
                    assessmentLoaded = true;
                }
            } else {
                console.log('‚ÑπÔ∏è No existing progress found for user:', currentUserId);
            }
        } else {
            console.log('‚ö†Ô∏è Running in offline mode');
            showStatusMessage('Running in offline mode - responses will not be saved', 'info');
        }
        
        if (!assessmentLoaded) {
            // No existing progress or failed to load - start fresh
            console.log('üÜï Starting fresh assessment');
            
            // Set up UI for new assessment
            document.getElementById('userInputSection').classList.add('hidden');
            document.getElementById('assessmentHeader').style.display = 'block';
            document.getElementById('navigationSection').style.display = 'flex';
            
            // Start from first question
            showQuestion(0);
        }
        
        // Set up comprehensive session metadata and tracking
        sessionMetadata = {
            sessionId: `people_ops_sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            startTime: new Date().toISOString(),
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            screenResolution: `${screen.width}x${screen.height}`,
            viewportSize: { width: window.innerWidth, height: window.innerHeight },
            devicePixelRatio: window.devicePixelRatio,
            colorDepth: screen.colorDepth,
            touchSupport: 'ontouchstart' in window,
            cookiesEnabled: navigator.cookieEnabled,
            onlineStatus: navigator.onLine,
            referrer: document.referrer || 'direct',
            entryUrl: window.location.href
        };
        
        assessmentStarted = true;
        startTime = new Date();
        
        console.log('‚úÖ Assessment initialization complete');
        console.log(`üìä Final state: Navigation visible, can edit responses: ${assessmentLoaded}`);
        
    } catch (error) {
        console.error('‚ùå Error starting assessment:', error);
        showStatusMessage(`‚ùå Error loading assessment: ${error.message}`, 'error');
        
        // Restore button state
        startButton.innerHTML = originalText;
        startButton.disabled = false;
    } finally {
        // Reset button if not successful
        if (startButton.disabled && !assessmentStarted) {
            startButton.innerHTML = originalText;
            startButton.disabled = false;
        }
    }
}

        function findNextQuestionIndex() {
            for (let i = 0; i < allQuestions.length; i++) {
                if (!responses[allQuestions[i].id]) {
                    return i;
                }
            }
            return allQuestions.length; // All questions answered
        }

        function restoreAssessmentState(assessmentData) {
            if (!assessmentData) {
                console.log('‚ÑπÔ∏è No assessment data to restore');
                return false;
            }
            
            console.log('üîÑ Restoring assessment state...');
            
            try {
                // Restore responses
                if (assessmentData.responses && Array.isArray(assessmentData.responses)) {
                    responses = {};
                    questionStates = {};
                    
                    assessmentData.responses.forEach(response => {
                        responses[response.question_id] = response;
                        
                        // Restore question state
                        questionStates[response.question_id] = {
                            status: "completed",
                            first_answered_at: response.answered_at,
                            last_modified_at: response.last_modified_at || response.answered_at,
                            modification_count: 0
                        };
                    });
                    
                    console.log(`‚úÖ Restored ${assessmentData.responses.length} responses`);
                }
                
                // Update UI
                updateProgress();
                
                return true;
                
            } catch (error) {
                console.error('‚ùå Error restoring assessment state:', error);
                return false;
            }
        }

        function showQuestion(questionIndex) {
            console.log(`üëÅÔ∏è Showing question ${questionIndex + 1} of ${allQuestions.length}`);
            
            if (questionIndex >= allQuestions.length) {
                finalizeCurrentChapterTiming();
                showFinalSection();
                return;
            }
            
            currentQuestionIndex = questionIndex;
            const question = allQuestions[questionIndex];
            
            trackChapterTiming(question.section);
            
            const questionHTML = generateQuestionHTML(question);
            document.getElementById('questionsContainer').innerHTML = questionHTML;
            
            autoSaveIndicator = null;
            
            if (!questionStates[question.id]) {
                initializeQuestionState(question.id);
            }
            
            setTimeout(() => {
                restoreQuestionResponse(question);
            }, 100);
            
            if (question.type === 'battle') {
                setTimeout(() => {
                    initializeTournament(question.id);
                }, 150);
            }
            
            updateNavigation();
            updateProgress();
        }

        // Track chapter timing
        function trackChapterTiming(sectionName) {
            const now = new Date();
            
            if (currentChapter && currentChapter !== sectionName) {
                finalizeCurrentChapterTiming();
            }
            
            if (currentChapter !== sectionName) {
                console.log(`üìä Starting chapter timing for: ${sectionName}`);
                currentChapter = sectionName;
                currentChapterStartTime = now;
                
                if (!chapterTimings[sectionName]) {
                    chapterTimings[sectionName] = {
                        chapter_name: sectionName,
                        start_time: now.toISOString(),
                        end_time: null,
                        duration_seconds: 0,
                        questions_answered: 0,
                        first_question: null,
                        last_question: null
                    };
                }
            }
        }

        // Finalize current chapter timing
        function finalizeCurrentChapterTiming() {
            if (currentChapter && currentChapterStartTime && chapterTimings[currentChapter]) {
                const now = new Date();
                const durationSeconds = Math.floor((now - currentChapterStartTime) / 1000);
                
                chapterTimings[currentChapter].end_time = now.toISOString();
                chapterTimings[currentChapter].duration_seconds = durationSeconds;
                
                const chapterQuestions = allQuestions.filter(q => q.section === currentChapter);
                const answeredInChapter = chapterQuestions.filter(q => responses[q.id]);
                chapterTimings[currentChapter].questions_answered = answeredInChapter.length;
                
                if (answeredInChapter.length > 0) {
                    chapterTimings[currentChapter].first_question = chapterQuestions[0].id;
                    chapterTimings[currentChapter].last_question = chapterQuestions[chapterQuestions.length - 1].id;
                }
                
                console.log(`‚úÖ Finalized chapter timing for ${currentChapter}: ${durationSeconds}s`);
            }
        }

        function generateQuestionHTML(question) {
            const questionId = question.id;
            const safeId = createSafeId(questionId);
            
            let html = `
                <div class="mind-expansion active">
                    <div class="expansion-header">
                        <h2 class="expansion-title">${question.section}</h2>
                        <p class="expansion-subtitle">People & Operations Foundation Assessment</p>
                    </div>
                    
                    <div class="question" data-question-id="${safeId}">
                        <h3 class="question-title">${question.question}</h3>
                        ${question.subText ? `<p class="question-subtext">${question.subText}</p>` : ''}
            `;
            
            switch (question.type) {
                case 'card':
                    html += `
                        <div class="card-options">
                            ${question.options.map((option, index) => `
                                <div class="card-option" onclick="PeopleAnalyst.selectCardOption(this, '${questionId}', ${index})">
                                    <input type="radio" name="q${safeId}" value="${escapeHtml(option.title)}" data-option-value="${escapeHtml(option.title)}">
                                    <div class="card-option-title">${option.title}</div>
                                    ${option.subtitle ? `<div class="card-option-subtitle">${Array.isArray(option.subtitle) ? option.subtitle.join('<br>') : option.subtitle}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                
                case 'checkbox':
                    html += `
                        <div class="checkbox-options">
                            ${question.options.map((option, index) => `
                                <div class="checkbox-option" onclick="PeopleAnalyst.toggleCheckboxOption(this, '${questionId}')">
                                    <input type="checkbox" value="${escapeHtml(option)}" data-option-value="${escapeHtml(option)}">
                                    <div class="checkbox-option-label">${option}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                
                case 'text':
                    html += `
                        <textarea class="text-input" placeholder="${question.placeholder || ''}" 
                            maxlength="${question.maxLength || 500}" 
                            oninput="PeopleAnalyst.handleTextInput(this, '${questionId}', ${question.maxLength || 500})"
                            ${question.required && !question.required === false ? 'required' : ''}></textarea>
                        <div class="char-counter">0/${question.maxLength || 500}</div>
                        ${question.required === false ? '<p style="font-size: 0.9em; color: #666; text-align: center; margin-top: 5px;">Optional</p>' : ''}
                    `;
                    break;
                
                case 'slider':
                    const defaultValue = question.min !== undefined && question.max !== undefined ? 
                        ((question.min + question.max) / 2) : 2.5;
                    html += `
                        <div class="slider-container">
                            <div class="slider-value">${defaultValue.toFixed(1)}</div>
                            <input type="range" class="slider-input" 
                                min="${question.min || 0}" max="${question.max || 5}" step="${question.step || 0.1}" 
                                value="${defaultValue}"
                                oninput="PeopleAnalyst.handleSliderInput(this, '${questionId}')">
                            <div class="slider-labels">
                                <span>${question.minLabel}</span>
                                <span>${question.maxLabel}</span>
                            </div>
                        </div>
                    `;
                    break;
                
                case 'multi-slider':
                    html += `
                        <div class="matrix-slider-container">
                            ${question.options.map((option, index) => `
                                <div class="matrix-slider-item">
                                    <div class="matrix-slider-label">${option}</div>
                                    <div class="matrix-slider-value">2.5</div>
                                    <input type="range" class="matrix-slider-input" 
                                        min="${question.min || 0}" max="${question.max || 5}" step="${question.step || 1}" value="2.5"
                                        oninput="PeopleAnalyst.handleMatrixSliderInput(this, '${questionId}', ${index})">
                                    <div class="matrix-slider-scale">
                                        <span>${question.minLabel}</span>
                                        <span>${question.maxLabel}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                
                case 'select':
                    html += `
                        <div class="select-options">
                            ${question.options.map((option, index) => `
                                <div class="select-option" onclick="PeopleAnalyst.selectSingleChoice(this, '${questionId}', ${index})">
                                    <input type="radio" name="q${safeId}" value="${escapeHtml(option)}" data-option-value="${escapeHtml(option)}">
                                    <div class="select-option-label">${option}</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    break;
                
                case 'battle':
                    html += `
                        <div class="tournament-container" id="tournament_${safeId}">
                            <div class="battle-round-indicator" id="battle_indicator_${safeId}">Round 1 of 4</div>
                            <div class="battle-options" id="battle_options_${safeId}">
                                <!-- Battle options populated by initializeTournament -->
                            </div>
                        </div>
                    `;
                    break;
                
                default:
                    html += `<p>Unknown question type: ${question.type}</p>`;
            }
            
            html += `
                    </div>
                </div>
            `;
            
            return html;
        }

        function restoreQuestionResponse(question) {
            const questionId = question.id;
            const safeId = createSafeId(questionId);
            const savedResponse = responses[questionId];
            
            if (!savedResponse) return;
            
            console.log(`üîÑ Restoring response for question ${questionId}:`, savedResponse);
            
            switch (question.type) {
                case 'card':
                    const cardOptions = document.querySelectorAll('.card-option');
                    cardOptions.forEach(option => {
                        const input = option.querySelector('input');
                        if (input && savedResponse.response_data.selected_option) {
                            const savedValue = savedResponse.response_data.selected_option.value || savedResponse.response_data.selected_option;
                            if (input.value === savedValue) {
                                option.classList.add('selected');
                                input.checked = true;
                            }
                        }
                    });
                    break;
                    
                case 'checkbox':
                    const checkboxOptions = document.querySelectorAll('.checkbox-option');
                    const selectedOptions = savedResponse.response_data.selected_options || [];
                    checkboxOptions.forEach(option => {
                        const input = option.querySelector('input');
                        if (input && selectedOptions.includes(input.value)) {
                            option.classList.add('selected');
                            input.checked = true;
                        }
                    });
                    break;
                    
                case 'text':
                    const textInput = document.querySelector('.text-input');
                    const charCounter = document.querySelector('.char-counter');
                    if (textInput && savedResponse.response_data.response_text) {
                        textInput.value = savedResponse.response_data.response_text;
                        if (charCounter) {
                            const maxLength = textInput.getAttribute('maxlength') || 500;
                            charCounter.textContent = `${textInput.value.length}/${maxLength}`;
                        }
                    }
                    break;
                    
                case 'slider':
                    const slider = document.querySelector('.slider-input');
                    const sliderValue = document.querySelector('.slider-value');
                    if (slider && savedResponse.response_data.selected_value !== undefined) {
                        slider.value = savedResponse.response_data.selected_value;
                        if (sliderValue) {
                            sliderValue.textContent = parseFloat(savedResponse.response_data.selected_value).toFixed(1);
                        }
                    }
                    break;
                    
                case 'multi-slider':
                    const sliders = document.querySelectorAll('.matrix-slider-input');
                    const sliderValues = document.querySelectorAll('.matrix-slider-value');
                    const savedSliderData = savedResponse.response_data.slider_values || {};
                    
                    sliders.forEach((slider, index) => {
                        const questionText = question.options[index];
                        if (savedSliderData[questionText] !== undefined) {
                            slider.value = savedSliderData[questionText];
                            if (sliderValues[index]) {
                                sliderValues[index].textContent = parseFloat(savedSliderData[questionText]).toFixed(1);
                            }
                        }
                    });
                    break;
                    
                case 'select':
                    const selectOptions = document.querySelectorAll('.select-option');
                    selectOptions.forEach(option => {
                        const input = option.querySelector('input');
                        if (input && input.value === savedResponse.response_data.selected_option) {
                            option.classList.add('selected');
                            input.checked = true;
                        }
                    });
                    break;
            }
            
            showAutoSaveIndicator('saved');
        }

        // People Analyst namespace with interaction handlers
        const PeopleAnalyst = {
            selectCardOption: function(element, questionId, index) {
                console.log(`üÉè Card option selected for question ${questionId}, index: ${index}`);
                initializeQuestionState(questionId);
                
                const siblings = element.parentElement.children;
                for (let sibling of siblings) {
                    sibling.classList.remove('selected');
                    sibling.querySelector('input').checked = false;
                }
                
                element.classList.add('selected');
                const radio = element.querySelector('input');
                radio.checked = true;
                
                console.log(`üìä Card selection for ${questionId}:`, radio.value);
                this.updateResponse(questionId, radio.value, 'card');
            },

            selectSingleChoice: function(element, questionId, index) {
                console.log(`üìã Single choice selected for question ${questionId}, index: ${index}`);
                initializeQuestionState(questionId);
                
                const siblings = element.parentElement.children;
                for (let sibling of siblings) {
                    sibling.classList.remove('selected');
                    sibling.querySelector('input').checked = false;
                }
                
                element.classList.add('selected');
                const radio = element.querySelector('input');
                radio.checked = true;
                
                console.log(`üìä Single choice selection for ${questionId}:`, radio.value);
                this.updateResponse(questionId, radio.value, 'select');
            },

            toggleCheckboxOption: function(element, questionId) {
                console.log(`‚úÖ Checkbox toggle for question ${questionId}`);
                initializeQuestionState(questionId);
                
                const checkbox = element.querySelector('input[type="checkbox"]');
                checkbox.checked = !checkbox.checked;
                element.classList.toggle('selected', checkbox.checked);
                
                const selectedValues = this.getCheckboxValues(element.parentElement);
                console.log(`üìä Checkbox values for ${questionId}:`, selectedValues);
                this.updateResponse(questionId, selectedValues, 'checkbox');
            },

            handleTextInput: function(input, questionId, maxLength) {
                console.log(`üìù Text input for question ${questionId}: ${input.value.length} chars`);
                initializeQuestionState(questionId);
                
                const value = input.value;
                const counter = input.nextElementSibling;
                
                if (counter) {
                    counter.textContent = `${value.length}/${maxLength}`;
                }
                
                console.log(`üìä Text value for ${questionId}:`, value);
                this.updateResponse(questionId, value, 'text');
            },

            handleSliderInput: function(input, questionId) {
                console.log(`üéöÔ∏è Slider input for question ${questionId}: ${input.value}`);
                initializeQuestionState(questionId);
                
                const value = parseFloat(input.value);
                const valueDisplay = input.previousElementSibling;
                
                if (valueDisplay && valueDisplay.classList.contains('slider-value')) {
                    valueDisplay.textContent = value.toFixed(1);
                }
                
                console.log(`üìä Slider value for ${questionId}:`, value);
                this.updateResponse(questionId, value, 'slider');
            },

            handleMatrixSliderInput: function(input, questionId, index) {
                console.log(`üéõÔ∏è Matrix-slider input for question ${questionId}, slider ${index}: ${input.value}`);
                initializeQuestionState(questionId);
                
                const value = parseFloat(input.value);
                const valueDisplay = input.previousElementSibling;
                if (valueDisplay && valueDisplay.classList.contains('matrix-slider-value')) {
                    valueDisplay.textContent = value.toFixed(1);
                }
                
                const sliderContainer = input.closest('.matrix-slider-container');
                const sliders = sliderContainer.querySelectorAll('.matrix-slider-input');
                const questionData = this.findQuestionById(questionId);
                
                const sliderValues = {};
                Array.from(sliders).forEach((slider, i) => {
                    const questionText = questionData.options[i];
                    sliderValues[questionText] = parseFloat(slider.value);
                });
                
                console.log(`üìä Matrix-slider values for ${questionId}:`, sliderValues);
                this.updateResponse(questionId, sliderValues, 'multi-slider');
            },

            getCheckboxValues: function(container) {
                const checked = container.querySelectorAll('input:checked');
                return Array.from(checked).map(input => input.value);
            },

            findQuestionById: function(questionId) {
                return allQuestions.find(q => q.id === questionId);
            },

            updateResponse: function(questionId, value, questionType) {
                console.log(`üîÑ Updating response for question ${questionId}:`, value);
                initializeQuestionState(questionId);
                
                const now = new Date();
                const timeSpent = Math.floor((now - questionStartTimes[questionId]) / 1000);
                const questionData = this.findQuestionById(questionId);
                
                const isFirstAnswer = !questionStates[questionId].first_answered_at;
                questionStates[questionId] = {
                    ...questionStates[questionId],
                    status: "completed",
                    first_answered_at: isFirstAnswer ? now.toISOString() : questionStates[questionId].first_answered_at,
                    last_modified_at: now.toISOString(),
                    modification_count: isFirstAnswer ? 0 : (questionStates[questionId].modification_count || 0) + 1
                };

                let responseData = {};

                switch (questionType) {
                    case 'card':
                        responseData = {
                            selected_option: {
                                value: value,
                                label: value
                            }
                        };
                        break;
                    
                    case 'select':
                        responseData = {
                            selected_option: value
                        };
                        break;
                    
                    case 'checkbox':
                        responseData = {
                            selected_options: value,
                            selection_metadata: {
                                total_selections: value.length
                            }
                        };
                        break;
                    
                    case 'text':
                        const wordCount = value.trim().split(/\s+/).filter(word => word.length > 0).length;
                        
                        responseData = {
                            response_text: value,
                            response_status: "completed",
                            character_count: value.length,
                            word_count: wordCount
                        };
                        break;
                    
                    case 'slider':
                        responseData = {
                            selected_value: value,
                            selection_metadata: {
                                normalized_value: value / 10
                            }
                        };
                        break;
                    
                    case 'multi-slider':
                        responseData = {
                            slider_values: value,
                            response_metadata: {
                                total_sliders: Object.keys(value).length,
                                completion_rate: 1
                            }
                        };
                        break;
                    
                    case 'battle':
                        responseData = {
                            tournament_results: value
                        };
                        break;
                    
                    default:
                        responseData = { selected_value: value };
                }

                const response = {
                    question_id: questionId,
                    section: questionData ? questionData.section : 'Unknown',
                    question_type: questionType,
                    question_text: questionData ? questionData.question : 'Unknown',
                    response_format: this.getResponseFormat(questionType),
                    response_data: responseData,
                    all_options: questionData ? questionData.options : [],
                    metadata: {
                        time_spent_seconds: timeSpent,
                        final_answer_confidence: "high",
                        device_context: {
                            viewport_size: {
                                width: window.innerWidth,
                                height: window.innerHeight
                            },
                            device_type: this.getDeviceType(),
                            performance_during_question: {
                                memory_usage: {
                                    used: performance.memory ? performance.memory.usedJSHeapSize : 588542486,
                                    total: performance.memory ? performance.memory.totalJSHeapSize : 596835270,
                                    limit: performance.memory ? performance.memory.jsHeapSizeLimit : 4294705152,
                                    timestamp: now.toISOString()
                                },
                                connection_quality: this.getConnectionInfo()
                            }
                        },
                        timing_data: {
                            question_start_time: questionStartTimes[questionId].toISOString(),
                            answer_time: now.toISOString(),
                            total_engagement_time: timeSpent,
                            focus_time: timeSpent,
                            interaction_count: behaviorTracker.engagementData.interactions
                        }
                    },
                    ai_interpretation_guide: this.getAIGuide(questionType),
                    weight: this.getQuestionWeight(questionType),
                    answered_at: now.toISOString(),
                    last_modified_at: now.toISOString()
                };

                if (questionData?.subText) {
                    response.sub_text = questionData.subText;
                }
                if (questionData?.maxLength) {
                    response.character_limit = questionData.maxLength;
                }
                if (questionData?.required !== undefined) {
                    response.required = questionData.required;
                }

                responses[questionId] = response;
                console.log(`üíæ Response saved for ${questionId}:`, response);

                if (currentUserId && backendConnected) {
                    autoSaveResponse(questionId, response);
                } else {
                    console.log(`‚è≠Ô∏è Skipping auto-save for ${questionId} - offline mode`);
                    showAutoSaveIndicator('saved');
                }
                
                updateProgress();
                
                // Auto-advance logic for certain question types
                if (questionType === 'card' || questionType === 'select') {
                    setTimeout(() => {
                        if (currentQuestionIndex < allQuestions.length - 1) {
                            nextQuestion();
                        }
                    }, 1500);
                }
            },

            getResponseFormat: function(questionType) {
                const formatMap = {
                    'card': 'string',
                    'select': 'string',
                    'checkbox': 'array',
                    'text': 'text',
                    'slider': 'numeric',
                    'multi-slider': 'object',
                    'battle': 'tournament_results'
                };
                return formatMap[questionType] || 'string';
            },

            getDeviceType: function() {
                const width = window.innerWidth;
                if (width < 768) return 'mobile';
                if (width < 1024) return 'tablet';
                return 'desktop';
            },

            getConnectionInfo: function() {
                if ('connection' in navigator) {
                    return {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    };
                }
                return {
                    effectiveType: "4g",
                    downlink: 6.65,
                    rtt: 50,
                    saveData: false
                };
            },

            getAIGuide: function(questionType) {
                const guides = {
                    'card': 'Analyze response for people management and leadership patterns.',
                    'select': 'Single selection reveals primary approach and priorities.',
                    'checkbox': 'Multiple selections reveal operational priorities and system gaps.',
                    'text': 'Open text reveals authentic insights into people challenges and organizational dynamics.',
                    'slider': 'Slider values indicate confidence levels and self-assessment accuracy.',
                    'multi-slider': 'Matrix responses show comprehensive risk assessment and operational maturity.',
                    'battle': 'Tournament format reveals core leadership development priorities through forced choices.'
                };
                return guides[questionType] || 'Analyze response for people and operational patterns.';
            },

            getQuestionWeight: function(questionType) {
                const weights = {
                    'battle': 'very_high',
                    'multi-slider': 'high',
                    'checkbox': 'high',
                    'card': 'medium',
                    'select': 'medium',
                    'slider': 'medium',
                    'text': 'medium'
                };
                return weights[questionType] || 'medium';
            }
        };

        // Tournament battle functionality
        function initializeTournament(questionId) {
            const questionData = allQuestions.find(q => q.id === questionId);
            if (!questionData || questionData.type !== 'battle') return;
            
            const battleOptions = questionData.options;
            
            tournamentState[questionId] = {
                battleOptions: battleOptions,
                currentRound: 1,
                maxRounds: 4,
                winners: [],
                roundData: [],
                finalWinner: null
            };
            
            showTournamentRound(questionId);
        }

        function showTournamentRound(questionId) {
            const state = tournamentState[questionId];
            const safeId = createSafeId(questionId);
            
            if (state.currentRound > state.maxRounds) {
                completeTournament(questionId);
                return;
            }
            
            let option1, option2;
            
            if (state.currentRound === 1) {
                const availableOptions = [...state.battleOptions];
                const index1 = Math.floor(Math.random() * availableOptions.length);
                option1 = { title: availableOptions[index1], description: "Leadership challenge" };
                availableOptions.splice(index1, 1);
                const index2 = Math.floor(Math.random() * availableOptions.length);
                option2 = { title: availableOptions[index2], description: "Leadership challenge" };
            } else if (state.currentRound <= 4 && state.battleOptions.length >= state.currentRound * 2) {
                const remainingOptions = state.battleOptions.filter(opt => 
                    !state.winners.some(winner => winner.title === opt)
                );
                if (remainingOptions.length >= 2) {
                    option1 = { title: remainingOptions[0], description: "Leadership challenge" };
                    option2 = { title: remainingOptions[1], description: "Leadership challenge" };
                } else {
                    option1 = { title: state.battleOptions[0], description: "Leadership challenge" };
                    option2 = { title: state.battleOptions[1], description: "Leadership challenge" };
                }
            } else {
                if (state.winners.length >= 2) {
                    option1 = state.winners[0];
                    option2 = state.winners[1];
                } else {
                    option1 = { title: state.battleOptions[0], description: "Leadership challenge" };
                    option2 = { title: state.battleOptions[1], description: "Leadership challenge" };
                }
            }
            
            const indicatorElement = document.getElementById(`battle_indicator_${safeId}`);
            const optionsElement = document.getElementById(`battle_options_${safeId}`);
            
            if (indicatorElement) {
                indicatorElement.textContent = `Round ${state.currentRound} of ${state.maxRounds}`;
            }
            
            if (optionsElement) {
                optionsElement.innerHTML = `
                    <div class="battle-option" onclick="selectTournamentOption('${questionId}', 0)">
                        <div style="font-weight: 700; font-size: 1.2em; margin-bottom: 10px;">${option1.title}</div>
                        <div style="font-size: 0.9em; color: #666;">${option1.description}</div>
                    </div>
                    <div class="battle-option" onclick="selectTournamentOption('${questionId}', 1)">
                        <div style="font-weight: 700; font-size: 1.2em; margin-bottom: 10px;">${option2.title}</div>
                        <div style="font-size: 0.9em; color: #666;">${option2.description}</div>
                    </div>
                `;
            }
            
            state.roundStartTime = new Date();
            state.currentOptions = [option1, option2];
        }

        function selectTournamentOption(questionId, selectedIndex) {
            const state = tournamentState[questionId];
            const selectionTime = new Date() - state.roundStartTime;
            const selectedOption = state.currentOptions[selectedIndex];
            
            state.roundData.push({
                round: state.currentRound,
                options_presented: state.currentOptions,
                selected: selectedOption,
                selection_time_ms: selectionTime
            });
            
            state.winners.push(selectedOption);
            
            if (state.currentRound === state.maxRounds) {
                state.finalWinner = selectedOption;
            }
            
            state.currentRound++;
            
            setTimeout(() => {
                showTournamentRound(questionId);
            }, 500);
        }

        function completeTournament(questionId) {
            const state = tournamentState[questionId];
            
            const tournamentResults = {
                total_rounds_completed: state.maxRounds,
                round_data: state.roundData,
                final_winner: state.finalWinner,
                leadership_development_priority: state.finalWinner?.title || "Not completed",
                tournament_path: state.winners
            };
            
            PeopleAnalyst.updateResponse(questionId, tournamentResults, 'battle');
            
            const safeId = createSafeId(questionId);
            const container = document.getElementById(`tournament_${safeId}`);
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; background: linear-gradient(135deg, #48bb78, #38a169); border-radius: 15px; color: white;">
                        <h3 style="font-size: 1.5em; margin-bottom: 15px;">üèÜ Leadership Development Priority Identified</h3>
                        <div style="font-size: 1.3em; font-weight: 700; margin-bottom: 10px;">${state.finalWinner?.title || "Unknown"}</div>
                        <div style="font-size: 1em; opacity: 0.9;">Your primary leadership development focus area</div>
                    </div>
                `;
            }
            
            // Auto-advance after tournament completion
            setTimeout(() => {
                if (currentQuestionIndex < allQuestions.length - 1) {
                    nextQuestion();
                }
            }, 2000);
        }

        window.selectTournamentOption = selectTournamentOption;

        // Navigation functions
        // üî• ALSO UPDATE: Modified nextQuestion function to handle final section properly
function nextQuestion() {
    console.log(`‚û°Ô∏è Next question requested (current: ${currentQuestionIndex + 1})`);
    
    if (currentQuestionIndex < allQuestions.length - 1) {
        console.log(`üìù Moving from question ${currentQuestionIndex + 1} to ${currentQuestionIndex + 2}`);
        showQuestion(currentQuestionIndex + 1);
        window.scrollTo(0, 0);
        console.log('‚úÖ Successfully moved to next question');
    } else {
        console.log('üèÅ Reached end of questions, showing final section');
        finalizeCurrentChapterTiming();
        showFinalSection();
        window.scrollTo(0, 0);
        console.log('‚úÖ Final section displayed');
    }
}

// üî• ENHANCEMENT: Add function to jump to specific question (useful for review)
function jumpToQuestion(questionIndex) {
    console.log(`üéØ Jumping to question ${questionIndex + 1} of ${allQuestions.length}`);
    
    // Validate question index
    if (questionIndex < 0 || questionIndex >= allQuestions.length) {
        console.error(`‚ùå Invalid question index: ${questionIndex}. Must be 0-${allQuestions.length - 1}`);
        return false;
    }
    
    // Hide final section if it's active
    const finalSectionActive = document.getElementById('finalSection').classList.contains('active');
    if (finalSectionActive) {
        document.getElementById('finalSection').classList.remove('active');
        console.log('‚úÖ Final section hidden for question jump');
    }
    
    // Show the target question
    showQuestion(questionIndex);
    
    // Ensure navigation is visible
    document.getElementById('navigationSection').style.display = 'flex';
    
    // Scroll to top
    window.scrollTo(0, 0);
    
    console.log(`‚úÖ Successfully jumped to question ${questionIndex + 1}`);
    return true;
}

// Make jumpToQuestion globally accessible for debugging
window.jumpToQuestion = jumpToQuestion;


        function previousQuestion() {
    console.log(`‚¨ÖÔ∏è Previous question requested (current: ${currentQuestionIndex + 1})`);
    
    // üî• CRITICAL FIX: Handle navigation from final section
    const finalSectionActive = document.getElementById('finalSection').classList.contains('active');
    
    if (finalSectionActive) {
        console.log('üîô Navigating from final section back to questions');
        
        // Hide final section
        document.getElementById('finalSection').classList.remove('active');
        console.log('‚úÖ Final section hidden');
        
        // Show the last question for editing
        showQuestion(allQuestions.length - 1);
        console.log('‚úÖ Showing last question for editing');
        
        // Scroll to top for better UX
        window.scrollTo(0, 0);
        console.log('‚úÖ Scrolled to top');
        
        return; // Exit early since we handled the final section case
    }
    
    // üî• STANDARD NAVIGATION: Handle normal question-to-question navigation
    if (currentQuestionIndex > 0) {
        console.log(`üìù Moving from question ${currentQuestionIndex + 1} to ${currentQuestionIndex}`);
        showQuestion(currentQuestionIndex - 1);
        window.scrollTo(0, 0);
        console.log('‚úÖ Successfully moved to previous question');
    } else {
        console.log('‚ö†Ô∏è Already at first question, cannot go back further');
    }
}

        function showFinalSection() {
    console.log('üèÅ Showing final section with enhanced edit capability and comprehensive user experience');
    console.log('üìä Final section state: allowing response review, editing, and complete user control');
    
    const functionStartTime = new Date();
    console.log(`‚è∞ Function start time: ${functionStartTime.toISOString()}`);
    
    // Finalize timing data for analytics
    finalizeCurrentChapterTiming();
    console.log('‚úÖ Chapter timing finalized for analytics');
    
    // Clear questions container with validation
    const questionsContainer = document.getElementById('questionsContainer');
    if (questionsContainer) {
        questionsContainer.innerHTML = '';
        console.log('‚úÖ Questions container cleared successfully');
    } else {
        console.error('‚ùå Questions container not found - potential DOM issue');
    }
    
    // Show final section with validation
    const finalSection = document.getElementById('finalSection');
    if (finalSection) {
        finalSection.classList.add('active');
        console.log('‚úÖ Final section activated successfully');
    } else {
        console.error('‚ùå Final section element not found - potential DOM issue');
        return; // Exit if critical element missing
    }
    
    // üî• CRITICAL FIX: Keep navigation visible for editing instead of hiding it
    const navigationSection = document.getElementById('navigationSection');
    if (navigationSection) {
        navigationSection.style.display = 'flex';
        console.log('‚úÖ Navigation section kept visible for response editing');
    } else {
        console.error('‚ùå Navigation section not found - navigation will not be available');
    }
    
    // üî• ENHANCEMENT: Comprehensive navigation button configuration for final section context
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const status = document.getElementById('questionStatus');
    
    // Validate navigation elements exist
    if (!prevBtn || !nextBtn || !status) {
        console.error('‚ùå Navigation elements missing:', {
            prevBtn: !!prevBtn,
            nextBtn: !!nextBtn, 
            status: !!status
        });
        console.error('üîß Navigation functionality may be impaired');
    }
    
    // Configure previous button for reviewing responses
    if (prevBtn) {
        prevBtn.disabled = false;
        prevBtn.textContent = '‚Üê Review & Edit Responses';
        prevBtn.style.display = 'block'; // Ensure it's visible
        prevBtn.style.background = 'linear-gradient(135deg, #4299e1, #3182ce)'; // Different color for review mode
        console.log('‚úÖ Previous button configured for response review');
        console.log(`   - Text: "${prevBtn.textContent}"`);
        console.log(`   - Enabled: ${!prevBtn.disabled}`);
        console.log(`   - Visible: ${prevBtn.style.display !== 'none'}`);
    }
    
    // Hide next button since we're at the end
    if (nextBtn) {
        nextBtn.style.display = 'none';
        console.log('‚úÖ Next button hidden (end of assessment)');
    }
    
    // Update status text for final section with enhanced information
    if (status) {
        const totalResponses = Object.keys(responses).length;
        const completionPercentage = Math.round((totalResponses / allQuestions.length) * 100);
        status.textContent = `Assessment Complete - ${totalResponses}/${allQuestions.length} responses (${completionPercentage}%) - Review Available`;
        console.log('‚úÖ Status text updated for final section with detailed completion info');
    }
    
    // üî• COMPREHENSIVE METRICS: Calculate and log detailed completion metrics
    const totalResponses = Object.keys(responses).length;
    const totalQuestions = allQuestions.length;
    const completionPercentage = Math.round((totalResponses / totalQuestions) * 100);
    const assessmentDuration = Math.floor((new Date() - startTime) / 1000);
    const averageTimePerQuestion = Math.round(assessmentDuration / Math.max(totalResponses, 1));
    
    // Calculate section completion breakdown
    const sectionCompletionStats = {};
    const allSections = [...new Set(allQuestions.map(q => q.section))];
    
    allSections.forEach(section => {
        const sectionQuestions = allQuestions.filter(q => q.section === section);
        const sectionResponses = sectionQuestions.filter(q => responses[q.id]);
        const sectionCompletion = Math.round((sectionResponses.length / sectionQuestions.length) * 100);
        
        sectionCompletionStats[section] = {
            total_questions: sectionQuestions.length,
            answered_questions: sectionResponses.length,
            completion_percentage: sectionCompletion,
            section_complete: sectionCompletion === 100
        };
    });
    
    // Calculate response quality metrics
    const textResponses = Object.values(responses).filter(r => r.question_type === 'text');
    const totalWordsWritten = textResponses.reduce((sum, r) => {
        return sum + (r.response_data?.word_count || 0);
    }, 0);
    
    const sliderResponses = Object.values(responses).filter(r => r.question_type === 'slider' || r.question_type === 'multi-slider');
    const averageEngagementTime = Object.values(responses).reduce((sum, r) => {
        return sum + (r.metadata?.time_spent_seconds || 0);
    }, 0) / Math.max(totalResponses, 1);
    
    // Log comprehensive final section metrics
    console.log('üìä COMPREHENSIVE FINAL SECTION METRICS:');
    console.log(`   üéØ Overall Completion:`);
    console.log(`      - Total responses: ${totalResponses}/${totalQuestions}`);
    console.log(`      - Completion percentage: ${completionPercentage}%`);
    console.log(`      - Assessment duration: ${assessmentDuration}s (${Math.round(assessmentDuration/60)}m ${assessmentDuration%60}s)`);
    console.log(`      - Average time per question: ${averageTimePerQuestion}s`);
    console.log(`      - Total words written: ${totalWordsWritten}`);
    console.log(`      - Average engagement time: ${Math.round(averageEngagementTime)}s`);
    
    console.log(`   üìã Section Breakdown:`);
    allSections.forEach(section => {
        const stats = sectionCompletionStats[section];
        const statusIcon = stats.section_complete ? '‚úÖ' : '‚ö†Ô∏è';
        console.log(`      ${statusIcon} ${section}: ${stats.answered_questions}/${stats.total_questions} (${stats.completion_percentage}%)`);
    });
    
    console.log(`   üß≠ Navigation Configuration:`);
    console.log(`      - Navigation visible: YES`);
    console.log(`      - Edit capability: ENABLED`);
    console.log(`      - Previous button: ACTIVE for review (${prevBtn ? prevBtn.textContent : 'NOT FOUND'})`);
    console.log(`      - Next button: HIDDEN (end of assessment)`);
    console.log(`      - Status display: Enhanced with completion details`);
    
    console.log(`   üéÆ User Experience Features:`);
    console.log(`      - Can navigate back to any question: YES`);
    console.log(`      - Can edit any response: YES`);
    console.log(`      - Auto-save on edits: ${backendConnected ? 'ENABLED' : 'DISABLED (offline)'}`);
    console.log(`      - Can return to final section: YES`);
    console.log(`      - Submit when ready: YES`);
    
    // üî• BEHAVIORAL ANALYTICS: Calculate final behavioral insights for the session
    const totalMouseMovements = behaviorTracker.engagementData.totalMovements;
    const totalMouseDistance = behaviorTracker.engagementData.totalDistance;
    const averageMouseSpeed = totalMouseDistance / Math.max(totalMouseMovements, 1);
    const clickDensity = behaviorTracker.engagementData.interactions / Math.max(assessmentDuration, 1);
    const keystrokeDensity = behaviorTracker.totalKeystrokes / Math.max(assessmentDuration, 1);
    
    console.log(`   üß† Behavioral Analytics Summary:`);
    console.log(`      - Mouse movements: ${totalMouseMovements}`);
    console.log(`      - Mouse distance: ${Math.round(totalMouseDistance)}px`);
    console.log(`      - Average mouse speed: ${Math.round(averageMouseSpeed)}px/movement`);
    console.log(`      - Click density: ${clickDensity.toFixed(2)} clicks/second`);
    console.log(`      - Keystroke density: ${keystrokeDensity.toFixed(2)} keys/second`);
    console.log(`      - Total keystrokes: ${behaviorTracker.totalKeystrokes}`);
    console.log(`      - Scroll events: ${behaviorTracker.scrollBehavior.length}`);
    
    // üî• ASSESSMENT QUALITY: Calculate overall assessment quality score
    const responseCompleteness = completionPercentage / 100;
    const textQuality = Math.min(1, totalWordsWritten / 500); // Quality based on written content
    const engagementQuality = Math.min(1, averageEngagementTime / 60); // Quality based on time spent
    const interactionQuality = Math.min(1, clickDensity * 10); // Quality based on interaction level
    
    const overallQualityScore = (
        responseCompleteness * 0.4 + 
        textQuality * 0.2 + 
        engagementQuality * 0.2 + 
        interactionQuality * 0.2
    );
    
    console.log(`   üìä Assessment Quality Analysis:`);
    console.log(`      - Response completeness: ${(responseCompleteness * 100).toFixed(1)}%`);
    console.log(`      - Text quality score: ${(textQuality * 100).toFixed(1)}%`);
    console.log(`      - Engagement quality: ${(engagementQuality * 100).toFixed(1)}%`);
    console.log(`      - Interaction quality: ${(interactionQuality * 100).toFixed(1)}%`);
    console.log(`      - OVERALL QUALITY SCORE: ${(overallQualityScore * 100).toFixed(1)}%`);
    
    // üî• DATA READINESS: Assess readiness for AI analysis
    const hasTextResponses = textResponses.length > 0;
    const hasSliderResponses = sliderResponses.length > 0;
    const hasMultipleChoiceResponses = Object.values(responses).some(r => 
        r.question_type === 'checkbox' || r.question_type === 'card' || r.question_type === 'select'
    );
    const hasBattleResponses = Object.values(responses).some(r => r.question_type === 'battle');
    
    const dataRichnessScore = [
        hasTextResponses,
        hasSliderResponses, 
        hasMultipleChoiceResponses,
        hasBattleResponses,
        totalWordsWritten > 100,
        totalResponses >= totalQuestions * 0.8
    ].filter(Boolean).length / 6;
    
    console.log(`   ü§ñ AI Analysis Readiness:`);
    console.log(`      - Has text responses: ${hasTextResponses} (${textResponses.length} responses)`);
    console.log(`      - Has slider responses: ${hasSliderResponses} (${sliderResponses.length} responses)`);
    console.log(`      - Has multiple choice: ${hasMultipleChoiceResponses}`);
    console.log(`      - Has battle tournament: ${hasBattleResponses}`);
    console.log(`      - Sufficient text content: ${totalWordsWritten > 100} (${totalWordsWritten} words)`);
    console.log(`      - Sufficient completion: ${totalResponses >= totalQuestions * 0.8}`);
    console.log(`      - DATA RICHNESS SCORE: ${(dataRichnessScore * 100).toFixed(1)}%`);
    console.log(`      - READY FOR AI ANALYSIS: ${dataRichnessScore >= 0.7 ? 'YES' : 'NEEDS MORE DATA'}`);
    
    // üî• SESSION ANALYTICS: Comprehensive session analysis
    const sessionDurationMinutes = Math.round(assessmentDuration / 60);
    const questionsPerMinute = totalResponses / Math.max(sessionDurationMinutes, 1);
    const deviceType = window.innerWidth < 768 ? 'mobile' : window.innerWidth < 1024 ? 'tablet' : 'desktop';
    const browserInfo = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    };
    
    console.log(`   üì± Session Analytics:`);
    console.log(`      - Session duration: ${sessionDurationMinutes} minutes`);
    console.log(`      - Questions per minute: ${questionsPerMinute.toFixed(1)}`);
    console.log(`      - Device type: ${deviceType}`);
    console.log(`      - Screen resolution: ${screen.width}x${screen.height}`);
    console.log(`      - Viewport size: ${window.innerWidth}x${window.innerHeight}`);
    console.log(`      - Browser: ${browserInfo.userAgent.split(' ')[0]}`);
    console.log(`      - Platform: ${browserInfo.platform}`);
    console.log(`      - Language: ${browserInfo.language}`);
    console.log(`      - Timezone: ${browserInfo.timezone}`);
    console.log(`      - Connection: ${backendConnected ? 'ONLINE' : 'OFFLINE'}`);
    
    // üî• USER EXPERIENCE ENHANCEMENTS: Add visual feedback and guidance
    if (finalSection) {
        // Add edit instructions to final section if not already present
        let editInstructions = finalSection.querySelector('.edit-instructions');
        if (!editInstructions) {
            editInstructions = document.createElement('div');
            editInstructions.className = 'edit-instructions';
            editInstructions.style.cssText = `
                background: rgba(102, 126, 234, 0.1);
                border: 2px solid #667eea;
                border-radius: 15px;
                padding: 20px;
                margin: 20px auto;
                max-width: 600px;
                text-align: center;
                color: #667eea;
                font-weight: 600;
                line-height: 1.6;
            `;
            editInstructions.innerHTML = `
                <div style="font-size: 1.2em; margin-bottom: 10px;">üìù Want to Review or Edit Your Responses?</div>
                <div style="font-size: 1em;">Click "‚Üê Review & Edit Responses" below to navigate through all ${totalQuestions} questions.</div>
                <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.8;">Changes are automatically saved. Return here when ready to submit.</div>
            `;
            
            // Insert before the submit button
            const submitButton = finalSection.querySelector('.submit-button');
            if (submitButton) {
                finalSection.insertBefore(editInstructions, submitButton);
                console.log('‚úÖ Edit instructions added to final section');
            }
        }
        
        // Update completion statistics in final section
        let completionStats = finalSection.querySelector('.completion-stats');
        if (!completionStats) {
            completionStats = document.createElement('div');
            completionStats.className = 'completion-stats';
            completionStats.style.cssText = `
                background: rgba(255, 255, 255, 0.9);
                border-radius: 12px;
                padding: 20px;
                margin: 20px auto;
                max-width: 500px;
                text-align: center;
                border: 1px solid #e2e8f0;
            `;
            
            // Insert after the subtitle
            const subtitle = finalSection.querySelector('.final-subtitle');
            if (subtitle) {
                subtitle.parentNode.insertBefore(completionStats, subtitle.nextSibling);
            }
        }
        
        completionStats.innerHTML = `
            <div style="font-size: 1.1em; font-weight: 700; color: #667eea; margin-bottom: 15px;">
                üìä Assessment Completion Summary
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center;">
                <div>
                    <div style="font-size: 2em; font-weight: 800; color: #48bb78;">${totalResponses}</div>
                    <div style="font-size: 0.9em; color: #666;">Questions Answered</div>
                </div>
                <div>
                    <div style="font-size: 2em; font-weight: 800; color: #667eea;">${completionPercentage}%</div>
                    <div style="font-size: 0.9em; color: #666;">Complete</div>
                </div>
            </div>
            <div style="margin-top: 15px; font-size: 0.9em; color: #666;">
                Session Duration: ${sessionDurationMinutes} minutes | Quality Score: ${(overallQualityScore * 100).toFixed(0)}%
            </div>
        `;
        
        console.log('‚úÖ Completion statistics updated in final section');
    }
    
    // üî• PROGRESS BAR: Update progress bar to show completion but maintain edit capability
    updateProgress();
    console.log('‚úÖ Progress bar updated to reflect final completion state');
    
    // üî• BACKEND INTEGRATION: Update backend with final completion status if connected
    if (backendConnected && currentUserId) {
        console.log('üîÑ Updating backend with final completion status...');
        
        // Save final completion state
        setTimeout(async () => {
            try {
                const currentChapterNum = getCurrentChapterNumber('Deep Reflection'); // Use last section
                const saveResult = await saveProgressToBackend(currentChapterNum);
                
                if (saveResult) {
                    console.log('‚úÖ Final completion status saved to backend');
                    showAutoSaveIndicator('saved');
                } else {
                    console.log('‚ö†Ô∏è Final completion status save failed - continuing in local mode');
                }
            } catch (error) {
                console.error('‚ùå Error saving final completion status:', error);
            }
        }, 1000); // Delay to ensure DOM updates complete
    } else {
        console.log('‚ÑπÔ∏è Offline mode - final completion status not saved to backend');
    }
    
    // üî• ACCESSIBILITY ENHANCEMENTS: Focus management and keyboard navigation
    if (prevBtn) {
        // Set focus to review button for keyboard users
        setTimeout(() => {
            prevBtn.focus();
            console.log('‚úÖ Focus set to review button for accessibility');
        }, 500);
    }
    
    // üî• SUBMISSION READINESS: Validate submission readiness
    const canSubmit = totalResponses >= Math.floor(totalQuestions * 0.8); // 80% completion required
    const submitBtn = document.getElementById('submitButton');
    
    if (submitBtn) {
        if (canSubmit) {
            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            console.log('‚úÖ Submit button enabled - assessment ready for submission');
        } else {
            submitBtn.disabled = true;
            submitBtn.style.opacity = '0.6';
            console.log(`‚ö†Ô∏è Submit button disabled - need ${Math.floor(totalQuestions * 0.8)} responses minimum (have ${totalResponses})`);
        }
    }
    
    // üî• FINAL LOGGING: Comprehensive completion summary
    const functionEndTime = new Date();
    const functionDuration = functionEndTime - functionStartTime;
    
    console.log('üéâ FINAL SECTION DISPLAY COMPLETED WITH FULL EDIT NAVIGATION CAPABILITY');
    console.log('üìä FINAL SUMMARY:');
    console.log(`   ‚úÖ Assessment completion: ${completionPercentage}% (${totalResponses}/${totalQuestions})`);
    console.log(`   ‚úÖ Edit navigation: FULLY FUNCTIONAL`);
    console.log(`   ‚úÖ User experience: ENHANCED with review capabilities`);
    console.log(`   ‚úÖ Data quality: ${(overallQualityScore * 100).toFixed(1)}% readiness for AI analysis`);
    console.log(`   ‚úÖ Backend integration: ${backendConnected ? 'CONNECTED (auto-save active)' : 'OFFLINE MODE'}`);
    console.log(`   ‚úÖ Submission readiness: ${canSubmit ? 'READY TO SUBMIT' : 'NEEDS MORE RESPONSES'}`);
    console.log(`   ‚úÖ Function execution time: ${functionDuration}ms`);
    console.log(`   ‚úÖ Timestamp: ${functionEndTime.toISOString()}`);
    
    // üî• USER GUIDANCE: Log next steps for user
    console.log('üë§ USER GUIDANCE:');
    console.log('   1. Review and edit responses using "‚Üê Review & Edit Responses" button');
    console.log('   2. Navigate through questions with ‚Üê ‚Üí buttons');
    console.log('   3. Make any changes needed (auto-saved if online)');
    console.log('   4. Return to this completion screen with "Complete Assessment ‚Üí"');
    console.log('   5. Submit when satisfied with responses');
    
    console.log('üéØ Final section initialization complete - user has full control');
}

        function updateNavigation() {
    console.log(`üß≠ Updating navigation for question ${currentQuestionIndex + 1} of ${allQuestions.length}`);
    
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const status = document.getElementById('questionStatus');
    
    // Check if final section is currently active
    const finalSectionActive = document.getElementById('finalSection').classList.contains('active');
    
    if (finalSectionActive) {
        console.log('üìã Navigation update: Final section is active, skipping standard navigation updates');
        // Don't update navigation when final section is active - it's handled by showFinalSection()
        return;
    }
    
    // üî• ENHANCEMENT: Ensure next button is always visible during question navigation
    nextBtn.style.display = 'block';
    console.log('‚úÖ Next button made visible for question navigation');
    
    // üî• STANDARD NAVIGATION: Previous button logic
    prevBtn.disabled = currentQuestionIndex === 0;
    prevBtn.textContent = '‚Üê Previous'; // Reset to standard text
    console.log(`‚úÖ Previous button: ${currentQuestionIndex === 0 ? 'DISABLED (first question)' : 'ENABLED'}`);
    
    // üî• ENHANCEMENT: Next button logic with better UX
    if (currentQuestionIndex === allQuestions.length - 1) {
        nextBtn.textContent = 'Complete Assessment ‚Üí';
        console.log('‚úÖ Next button text: Complete Assessment (last question)');
    } else {
        nextBtn.textContent = 'Next Question ‚Üí';
        console.log('‚úÖ Next button text: Next Question');
    }
    
    // üî• ENHANCEMENT: Status text with completion context
    const totalResponses = Object.keys(responses).length;
    status.textContent = `Question ${currentQuestionIndex + 1} of ${allQuestions.length} (${totalResponses} answered)`;
    console.log(`‚úÖ Status updated: Question ${currentQuestionIndex + 1}/${allQuestions.length}, ${totalResponses} responses`);
    
    // üî• ENHANCEMENT: Log detailed navigation state
    console.log('üìä Navigation state summary:');
    console.log(`   - Current question: ${currentQuestionIndex + 1}/${allQuestions.length}`);
    console.log(`   - Previous button: ${prevBtn.disabled ? 'DISABLED' : 'ENABLED'}`);
    console.log(`   - Next button: VISIBLE (${nextBtn.textContent})`);
    console.log(`   - Total responses: ${totalResponses}/${allQuestions.length}`);
    console.log(`   - Final section active: ${finalSectionActive}`);
    
    console.log(`üß≠ Navigation updated successfully for question ${currentQuestionIndex + 1}`);
}

function returnFromFinalSection() {
    console.log('üîô Returning from final section to edit responses');
    
    // Hide final section
    document.getElementById('finalSection').classList.remove('active');
    
    // Show the last question so user can navigate
    showQuestion(allQuestions.length - 1);
    
    // Show navigation
    document.getElementById('navigationSection').style.display = 'flex';
    
    // Update progress
    updateProgress();
}

// Make it globally accessible
window.returnFromFinalSection = returnFromFinalSection;

        function updateProgress() {
            const answeredQuestions = Object.keys(responses).length;
            const percentage = Math.min(100, Math.floor((answeredQuestions / allQuestions.length) * 100));
            
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${percentage}% Complete (${answeredQuestions}/${allQuestions.length} questions)`;
            document.getElementById('expansionIndicator').textContent = `Progress: ${answeredQuestions} of ${allQuestions.length} completed`;
            
            console.log(`üìä Progress updated: ${percentage}% (${answeredQuestions}/${allQuestions.length})`);
        }

        // Build complete assessment data for backend submission
        function buildPeopleAssessmentData() {
            console.log('üèóÔ∏è Building comprehensive People & Operations assessment data...');
            const endTime = new Date();
            const totalEngagementTime = Math.floor((endTime - startTime) / 1000);
            
            // Calculate sections completed and remaining
            const sectionsCompleted = [];
            const sectionsRemaining = [];
            
            const sectionNames = [...new Set(allQuestions.map(q => q.section))];
            sectionNames.forEach(section => {
                const sectionQuestions = allQuestions.filter(q => q.section === section);
                const answeredInSection = sectionQuestions.filter(q => responses[q.id]);
                const completionRate = answeredInSection.length / Math.max(sectionQuestions.length, 1);
                
                if (completionRate >= 0.5) {
                    sectionsCompleted.push(section);
                } else {
                    sectionsRemaining.push(section);
                }
            });

            const responseArray = Object.values(responses);
            responseArray.sort((a, b) => new Date(b.answered_at) - new Date(a.answered_at));
            const lastAnswered = responseArray[0];

            // Calculate behavioral analytics
            const averageSpeed = behaviorTracker.engagementData.totalDistance / 
                Math.max(behaviorTracker.engagementData.totalMovements, 1);
            
            const movementDensity = behaviorTracker.engagementData.totalMovements / Math.max(totalEngagementTime, 1);
            const interactionRate = (behaviorTracker.engagementData.interactions / Math.max(totalEngagementTime, 1)) * 60;
            
            const responseTimes = Object.values(responses).map(r => r.metadata?.time_spent_seconds || 0);
            const averageResponseTime = responseTimes.reduce((a, b) => a + b, 0) / Math.max(responseTimes.length, 1);
            
            const confidenceScores = Object.values(responses).map(r => r.metadata?.final_answer_confidence || 'high');
            const highConfidenceCount = confidenceScores.filter(c => c === 'high').length;
            const decisivenessScore = highConfidenceCount / Math.max(confidenceScores.length, 1);

            const textResponses = Object.values(responses).filter(r => r.question_type === 'text');
            const totalWords = textResponses.reduce((sum, r) => {
                const wordCount = r.response_data?.word_count || 0;
                return sum + wordCount;
            }, 0);

            // Tournament analysis
            let tournamentAnalysis = null;
            const tournamentResponses = Object.values(responses).filter(r => r.question_type === 'battle');
            if (tournamentResponses.length > 0) {
                const tournamentData = tournamentResponses[0].response_data?.tournament_results;
                if (tournamentData) {
                    tournamentAnalysis = {
                        leadership_priority: tournamentData.final_winner?.title || "Not completed",
                        tournament_completed: true,
                        total_rounds_completed: tournamentData.total_rounds_completed || 0,
                        development_focus: tournamentData.leadership_development_priority || "Unknown"
                    };
                }
            }

            // Calculate completion quality score
            const completionPercentage = Object.keys(responses).length / allQuestions.length;
            const engagementQuality = Math.min(1, interactionRate / 10);
            const responseQuality = Math.min(1, totalWords / 500);
            const completionQualityScore = ((completionPercentage * 0.4) + (engagementQuality * 0.3) + (responseQuality * 0.3));

            // Generate device fingerprint
            const deviceFingerprint = {
                user_agent: navigator.userAgent,
                platform: navigator.platform,
                screen_resolution: `${screen.width}x${screen.height}`,
                color_depth: screen.colorDepth,
                pixel_ratio: window.devicePixelRatio,
                timezone_offset: new Date().getTimezoneOffset(),
                language: navigator.language,
                languages: navigator.languages ? Array.from(navigator.languages) : [navigator.language],
                hardware_concurrency: navigator.hardwareConcurrency || 4,
                max_touch_points: navigator.maxTouchPoints || 0,
                connection_type: navigator.connection ? navigator.connection.effectiveType : 'unknown',
                memory: navigator.deviceMemory || 'unknown'
            };

            // Build all sections list
            const allSections = [...new Set(allQuestions.map(q => q.section))];

            const assessmentData = {
                assessment_metadata: {
                    user_id: currentUserId,
                    business_name: currentBusinessName,
                    assessment_type: "people_operations_foundation",
                    version: "1.0",
                    created_at: startTime.toISOString(),
                    last_updated: endTime.toISOString(),
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    session_metadata: {
                        ...sessionMetadata,
                        endTime: endTime.toISOString(),
                        totalEngagementTime: totalEngagementTime,
                        questionsAnswered: Object.keys(responses).length,
                        behaviorScore: engagementQuality
                    },
                    device_fingerprint: deviceFingerprint,
                    total_mind_expansions: allSections.length,
                    completed_mind_expansions: sectionsCompleted.length,
                    assessment_focus: "people_operations_foundation_analysis",
                    all_mind_expansions: allSections.map(section => `Section: ${section}`),
                    completion_quality_score: Math.round(completionQualityScore * 100) / 100
                },
                progress_tracking: {
                    total_questions: allQuestions.length,
                    answered_questions: Object.keys(responses).length,
                    skipped_questions: 0,
                    current_question_id: lastAnswered?.question_id || "1.1",
                    percentage_complete: Math.min(100, Math.floor((Object.keys(responses).length / allQuestions.length) * 100)),
                    estimated_time_remaining: sectionsRemaining.length > 0 ? `${sectionsRemaining.length * 2} minutes` : "Complete",
                    sections_completed: sectionsCompleted,
                    sections_remaining: sectionsRemaining,
                    last_question_answered: lastAnswered ? {
                        question_id: lastAnswered.question_id,
                        answered_at: lastAnswered.answered_at
                    } : null,
                    time_per_chapter: chapterTimings,
                    completion_status: {
                        is_fully_complete: Object.keys(responses).length >= allQuestions.length,
                        required_questions_answered: Object.keys(responses).length,
                        optional_questions_skipped: 0,
                        can_submit: Object.keys(responses).length >= Math.floor(allQuestions.length * 0.8)
                    }
                },
                question_states: questionStates,
                responses: Object.values(responses),
                completion_flags: {
                    assessment_completed: Object.keys(responses).length >= allQuestions.length,
                    ready_for_report_generation: Object.keys(responses).length >= 12,
                    minimum_questions_answered: Object.keys(responses).length >= 8,
                    all_required_questions_completed: Object.keys(responses).length >= allQuestions.length,
                    can_generate_partial_report: Object.keys(responses).length >= 8
                },
                comprehensive_metadata: {
                    behavioral_analytics: {
                        mouse_behavior: {
                            total_movements: behaviorTracker.engagementData.totalMovements,
                            total_distance: behaviorTracker.engagementData.totalDistance,
                            average_speed: averageSpeed,
                            click_patterns: behaviorTracker.clickPatterns,
                            scroll_behavior: behaviorTracker.scrollBehavior,
                            engagement_quality: {
                                movement_density: movementDensity,
                                interaction_rate: interactionRate,
                                engagement_score: Math.min(1, interactionRate / 10)
                            }
                        },
                        keyboard_behavior: {
                            total_keystrokes: behaviorTracker.totalKeystrokes,
                            typing_patterns: {},
                            keystroke_timings: behaviorTracker.keystrokeTimings,
                            text_input_quality: {
                                response_count: textResponses.length,
                                total_words: totalWords,
                                avg_words_per_response: textResponses.length > 0 ? totalWords / textResponses.length : 0,
                                quality_score: Math.min(1, totalWords / 100)
                            }
                        },
                        tournament_data: tournamentAnalysis,
                        decision_making_style: {
                            average_response_time: averageResponseTime,
                            confidence_distribution: confidenceScores,
                            total_engagement_time: totalEngagementTime,
                            decisiveness_score: decisivenessScore,
                            consistency_score: 0.9
                        },
                        attention_patterns: {
                            focus_time: totalEngagementTime,
                            distraction_events: 0,
                            deep_focus_sessions: Math.floor(totalEngagementTime / 300),
                            multitasking_indicators: behaviorTracker.scrollBehavior.length
                        },
                        leadership_decision_patterns: {
                            pattern_type: averageResponseTime < 30 ? 'quick_decisive' : averageResponseTime < 90 ? 'moderate_analytical' : 'deliberate_thoughtful',
                            decision_confidence: decisivenessScore,
                            response_consistency: 0.85
                        }
                    },
                    business_context: {
                        business_name: currentBusinessName,
                        business_stage: "foundation_evaluation",
                        assessment_focus: "human_architecture",
                        primary_areas: [
                            "people_architecture",
                            "leadership_reality", 
                            "revenue_engine",
                            "systems_reality",
                            "culture_engine",
                            "operational_foundations"
                        ],
                        leadership_development_priority: tournamentAnalysis?.leadership_priority || "Not identified",
                        foundation_readiness_score: decisivenessScore,
                        operational_maturity: Object.keys(responses).length >= 12 ? "advanced" : "developing"
                    },
                    contextual_analytics: {
                        temporal_context: {
                            start_time: startTime.toISOString(),
                            end_time: endTime.toISOString(),
                            day_of_week: startTime.getDay(),
                            hour_of_day: startTime.getHours(),
                            session_duration: totalEngagementTime,
                            completion_pace: totalEngagementTime / Math.max(Object.keys(responses).length, 1)
                        },
                        user_journey: {
                            question_sequence: Object.keys(responses),
                            completion_pattern: sectionsCompleted,
                            navigation_efficiency: totalEngagementTime / Math.max(Object.keys(responses).length, 1),
                            engagement_depth: behaviorTracker.engagementData.interactions / Math.max(Object.keys(responses).length, 1)
                        },
                        assessment_quality: {
                            response_completeness: Object.keys(responses).length / allQuestions.length,
                            data_richness_score: 1 + (totalWords / 1000),
                            strategic_insight_depth: decisivenessScore * 0.5,
                            ai_analysis_readiness: Math.min(100, (Object.keys(responses).length / allQuestions.length) * 100)
                        }
                    }
                }
            };
            
            console.log('üìä Enhanced People & Operations assessment data built:', {
                totalQuestions: assessmentData.progress_tracking.total_questions,
                answeredQuestions: assessmentData.progress_tracking.answered_questions,
                completion: assessmentData.progress_tracking.percentage_complete + '%',
                completionQuality: assessmentData.assessment_metadata.completion_quality_score,
                engagementTime: totalEngagementTime + 's',
                sectionsCompleted: sectionsCompleted.length + '/' + allSections.length
            });
            
            return assessmentData;
        }

        // Submit assessment using your backend endpoint
        async function submitAssessment() {
            console.log('üöÄ Submitting People & Operations assessment...');
            
            const submitButton = document.querySelector('.submit-button');
            const originalText = submitButton.innerHTML;
            
            submitButton.innerHTML = 'Generating Your Foundation Intelligence Report... <div class="loading-spinner"></div>';
            submitButton.disabled = true;
            
            showStatusMessage('Submitting your People & Operations foundation profile...', 'info');

            try {
                const assessmentData = buildPeopleAssessmentData();
                
                console.log('üìä Final People & Operations data summary:', {
                    totalQuestions: assessmentData.progress_tracking.total_questions,
                    answeredQuestions: assessmentData.progress_tracking.answered_questions,
                    completion: assessmentData.progress_tracking.percentage_complete + '%'
                });
                
                if (backendConnected) {
                    // Submit using your people-operations-audit endpoint
                    const reportResponse = await makeAPICall(`/people-operations-audit/${currentUserId}`, 'POST', {
                        user_id: currentUserId,
                        business_name: currentBusinessName,
                        assessment_data: assessmentData
                    });
                    
                    if (reportResponse && reportResponse.status === 'processing') {
                        console.log('‚úÖ People & Operations assessment submitted successfully:', reportResponse);
                        
                        // Show success message with report tracking
                        showStatusMessage('üéâ Assessment submitted successfully! Your Foundation Intelligence Report is being generated...', 'success');
                        submitButton.innerHTML = 'Foundation Report Being Generated...';
                        
                        // Start polling for report status
                        if (reportResponse.report_id) {
                            pollReportStatus(reportResponse.report_id);
                        }
                        
                    } else {
                        throw new Error('Unexpected response format from server');
                    }
                } else {
                    // Offline mode - just show completion
                    console.log('üìä Assessment completed in offline mode');
                    showStatusMessage('üéâ Assessment completed! (Offline mode - data not saved to database)', 'success');
                    submitButton.innerHTML = 'Assessment Complete (Offline Mode)';
                }
                
            } catch (error) {
                console.error('‚ùå Submission error:', error);
                showStatusMessage(`‚ùå Error submitting assessment: ${error.message}. Assessment data has been captured locally.`, 'error');
                
                submitButton.innerHTML = originalText;
                submitButton.disabled = false;
            }
        }

        // Poll report status using your backend endpoint
        async function pollReportStatus(reportId) {
            console.log(`üîÑ Polling report status for ${reportId}`);
            
            let pollCount = 0;
            const maxPolls = 60; // 5 minutes max (5 second intervals)
            
            const pollInterval = setInterval(async () => {
                pollCount++;
                
                try {
                    const statusResponse = await makeAPICall(`/people_ops_report_status/${reportId}`);
                    
                    console.log(`üìä Report status poll ${pollCount}:`, statusResponse);
                    
                    if (statusResponse.status === 'completed') {
                        clearInterval(pollInterval);
                        showStatusMessage('üéâ Foundation Intelligence Report completed successfully! Your report has been generated and saved.', 'success');
                        
                        const submitButton = document.querySelector('.submit-button');
                        submitButton.innerHTML = 'Foundation Report Generated Successfully!';
                        submitButton.disabled = true;
                        
                    } else if (statusResponse.status === 'failed') {
                        clearInterval(pollInterval);
                        showStatusMessage(`‚ùå Report generation failed: ${statusResponse.error || 'Unknown error'}`, 'error');
                        
                        const submitButton = document.querySelector('.submit-button');
                        submitButton.innerHTML = 'Report Generation Failed - Try Again';
                        submitButton.disabled = false;
                        
                    } else if (statusResponse.status === 'processing') {
                        // Update progress message
                        const message = statusResponse.message || 'Generating report...';
                        const progress = statusResponse.progress || 0;
                        showStatusMessage(`üîÑ ${message} (${progress}%)`, 'info');
                        
                    }
                    
                    if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        showStatusMessage('‚è∞ Report generation is taking longer than expected. Please check back later.', 'info');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error polling report status:', error);
                    
                    if (pollCount >= 5) { // Stop polling after 5 failed attempts
                        clearInterval(pollInterval);
                        showStatusMessage('‚ö†Ô∏è Unable to check report status. Your report may still be generating in the background.', 'info');
                    }
                }
            }, 5000); // Poll every 5 seconds
        }

        // Show status message
        function showStatusMessage(message, type = 'info') {
            console.log(`üì¢ Status message (${type}): ${message}`);
            const statusDiv = document.getElementById('submission-status');
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = `status-message status-${type}`;
                statusDiv.style.display = 'block';
                
                if (type !== 'error') {
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 8000);
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ Initializing People & Operations - The Foundation Engine');
            
            // Check backend connection on startup
            await checkBackendConnection();
            
            // Initialize behavioral tracking
            initializeBehavioralTracking();
            
            // Set up event listeners
            document.getElementById('startButton').addEventListener('click', startAssessment);
            document.getElementById('submitButton').addEventListener('click', submitAssessment);
            document.getElementById('nextBtn').addEventListener('click', nextQuestion);
            document.getElementById('prevBtn').addEventListener('click', previousQuestion);
            
            console.log('‚úÖ People & Operations Foundation Engine initialized successfully');
            console.log(`   üë• Total questions: ${allQuestions.length}`);
            console.log(`   üåê API URL: ${API_BASE_URL}`);
            console.log(`   üíæ Backend Connected: ${backendConnected}`);
            console.log(`   üìä Auto-Save: ${backendConnected ? 'Enabled' : 'Disabled (offline mode)'}`);
            console.log(`   üìä Behavioral Tracking: Enabled`);
        });

        // Enhanced keyboard navigation
        document.addEventListener('keydown', function(event) {
            if (assessmentStarted) {
                if (event.key === 'ArrowRight' && currentQuestionIndex < allQuestions.length - 1) {
                    console.log('‚å®Ô∏è Keyboard: Next question');
                    nextQuestion();
                } else if (event.key === 'ArrowLeft' && currentQuestionIndex > 0) {
                    console.log('‚å®Ô∏è Keyboard: Previous question');
                    previousQuestion();
                }
            }
        });

        // Periodic connection check
        setInterval(async () => {
            if (!backendConnected) {
                await checkBackendConnection();
            }
        }, 30000); // Check every 30 seconds

        // Debug functions for development
        window.peopleDebug = {
            // Basic debug functions
            getResponses: () => responses,
            getQuestionStates: () => questionStates,
            getAssessmentData: () => buildPeopleAssessmentData(),
            getAllQuestions: () => allQuestions,
            jumpToQuestion: (questionIndex) => showQuestion(questionIndex),
            clearAllResponses: () => {
                responses = {};
                questionStates = {};
                updateProgress();
            },
            getCurrentQuestion: () => allQuestions[currentQuestionIndex],
            getTournamentState: () => tournamentState,
            
            // Backend interaction debug functions
            checkConnection: () => checkBackendConnection(),
            getUserId: () => currentUserId,
            getBusinessName: () => currentBusinessName,
            loadProgress: async (userId) => await loadPreviousProgress(userId || currentUserId),
            saveProgress: async () => {
                const currentChapterNum = getCurrentChapterNumber(allQuestions[currentQuestionIndex]?.section);
                return await saveProgressToBackend(currentChapterNum);
            },
            
            // Test functions
            testSubmission: async () => {
                // Fill some responses for testing
                const testResponse = {
                    question_id: "1.1",
                    question_type: "card",
                    response_data: { selected_option: "Test Response" },
                    answered_at: new Date().toISOString()
                };
                responses["1.1"] = testResponse;
                
                return await submitAssessment();
            },
            
            // Report status checking
            checkReportStatus: async (reportId) => {
                if (reportId) {
                    return await makeAPICall(`/people_ops_report_status/${reportId}`);
                }
                return null;
            },
            
            // Simulate different assessment states for testing
            simulateCompletedAssessment: () => {
                // Fill all responses with test data
                allQuestions.forEach((q, index) => {
                    const testResponseData = {
                        card: { selected_option: { value: "Test Option", label: "Test Option" }},
                        select: { selected_option: "Test Option" },
                        checkbox: { selected_options: ["Test Option 1", "Test Option 2"] },
                        text: { response_text: "Test response text", word_count: 3 },
                        slider: { selected_value: 3.5 },
                        'multi-slider': { slider_values: { "Test Option": 3.0 }},
                        battle: { tournament_results: { final_winner: { title: "Test Winner" }}}
                    };
                    
                    responses[q.id] = {
                        question_id: q.id,
                        question_type: q.type,
                        response_data: testResponseData[q.type] || { test: true },
                        answered_at: new Date().toISOString()
                    };
                });
                updateProgress();
                console.log('üß™ Simulated completed assessment');
            },
            
            // Connection and API testing
            testApiConnection: async () => {
                try {
                    const health = await makeAPICall('/health');
                    console.log('‚úÖ API Health Check:', health);
                    return health;
                } catch (error) {
                    console.log('‚ùå API Health Check Failed:', error);
                    return null;
                }
            },
            
            getApiKeyHealth: async () => {
                try {
                    const health = await makeAPICall('/api-key-health');
                    console.log('üîë API Key Health:', health);
                    return health;
                } catch (error) {
                    console.log('‚ùå API Key Health Check Failed:', error);
                    return null;
                }
            }
        };

        console.log('üî¨ People & Operations - Enhanced with Backend Integration!');
        console.log(`   üîß Debug functions available at window.peopleDebug`);
        console.log(`   üíæ Responses auto-saved to backend database`);
        console.log(`   üì• Auto-restore previous progress on startup`);
        console.log(`   üèÜ Full behavioral analytics and progress tracking`);
        console.log(`   üåê Backend API: ${API_BASE_URL}`);
        </script>
    </body>
</html>